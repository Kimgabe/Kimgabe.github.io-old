---
title: "[파이썬 기초] 05. Numpy_ndarray 기본 함수(연산, 통계, 집계 등)"
cover: "https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=1920&h=1080&fit=crop"
date: 2021-07-14
categories:
  - [personal-study, numpy]
tags:
  - python
  - np.add
  - np.divide
  - np.mod
  - np.mean
  - np.median
  - np.max
  - np.min
  - np.argmax
  - np.argmin
  - np.var
  - np.std
  - np.sum
  - np.consum
  - np.any
  - np.all
  - np.where
toc: true
---
Numpy의 ndarray에 대한 기본적인 연산, 통계, 집계를 하는 방법을 정리합니다.

```python
import numpy as np
```

**numpy documentation**

 - [numpy 공식 문서 링크](https://www.numpy.org/devdocs/reference/)

 - numpy에서 제공되는 함수등에 대한 문서

```python
# 0 ~ 14 사이의 vector을 3행 5열로 생성
x = np.arange(15).reshape(3, 5)

# 0 ~ 1 사이의값 15개를 random으로 샘플링해서 3행 5열로 생성
y = np.random.rand(15).reshape(3, 5)
print("x:\n",x,"\n")

print("y:\n",y)
```


x:
 [[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]] 

y:
 [[0.16175123 0.3487249  0.26680599 0.60948813 0.64616021]
 [0.18404028 0.79156974 0.74045543 0.89539755 0.58879194]
 [0.83167547 0.2982453  0.98482872 0.09513154 0.7416586 ]]

# 연산 함수

 - add, substract, multiply, divide

## add

```python
# 각 요소의 위치가 동일한 것 끼리 더하기
# shape가 다르면 실행되지 않는다.
np.add(x, y)
```


array([[ 0.16175123,  1.3487249 ,  2.26680599,  3.60948813,  4.64616021],
       [ 5.18404028,  6.79156974,  7.74045543,  8.89539755,  9.58879194],
       [10.83167547, 11.2982453 , 12.98482872, 13.09513154, 14.7416586 ]])


```python
print("x의 shape:", x.shape)
print("y의 shape:", y.shape)
```


x의 shape: (3, 5)
y의 shape: (3, 5)


```python
# 4행 4열 배열로 y2 생성
y2 = np.random.rand(16).reshape(4, -1)
print("y2의 shape:", y2.shape)
```


y2의 shape: (4, 4)


```python
# shape가 다르면 실행되지 않는다.
np.add(x, y2)
```

## divide

```python
np.divide(x, y)
```


array([[  0.        ,   2.86758987,   7.49608367,   4.92216316,
          6.19041522],
       [ 27.16796518,   7.57987544,   9.45364124,   8.93457882,
         15.28553538],
       [ 12.0239208 ,  36.88239208,  12.18485987, 136.65289094,
         18.87660969]])

**사칙연산자를 통해서도 가능하다.**

- 더 보편적인 방법 (굳이 함수를 사용하지 않는다.)

```python
x + y
```


array([[ 0.16175123,  1.3487249 ,  2.26680599,  3.60948813,  4.64616021],
       [ 5.18404028,  6.79156974,  7.74045543,  8.89539755,  9.58879194],
       [10.83167547, 11.2982453 , 12.98482872, 13.09513154, 14.7416586 ]])


```python
x / y
```


array([[  0.        ,   2.86758987,   7.49608367,   4.92216316,
          6.19041522],
       [ 27.16796518,   7.57987544,   9.45364124,   8.93457882,
         15.28553538],
       [ 12.0239208 ,  36.88239208,  12.18485987, 136.65289094,
         18.87660969]])

# 통계 함수

 - 평균, 분산, 중앙, 최대, 최소값 등등 통계 관련된 함수가 내장

```python
print("y:\n",y)
```


y:
 [[0.16175123 0.3487249  0.26680599 0.60948813 0.64616021]
 [0.18404028 0.79156974 0.74045543 0.89539755 0.58879194]
 [0.83167547 0.2982453  0.98482872 0.09513154 0.7416586 ]]

## 평균

```python
np.mean(y)
```


0.5456483356147267


```python
y.mean()
```


0.5456483356147267

## 최대값

```python
np.max(y)
```


0.9848287238775228

### 최대값의 index를 가져오기

- flatten한 상태라 가정하고 최대값이 있는 index를 가져온다.

```python
np.argmax(y)
```


12

## 분산

```python
np.var(y)
```


0.0805830034326692

## 중앙값

```python
np.median(y)
```


0.609488126035035

## 표준편차

```python
np.std(y)
```


0.28387145582581774

# 집계함수

 - 합계(sum), 누적합계(cumsum) 등등 계산 가능

```python
print("y:\n",y)
```


y:
 [[0.16175123 0.3487249  0.26680599 0.60948813 0.64616021]
 [0.18404028 0.79156974 0.74045543 0.89539755 0.58879194]
 [0.83167547 0.2982453  0.98482872 0.09513154 0.7416586 ]]

## sum

```python
# 각 행의 동일 열끼리의 합
# column wise
sum(y)
```


array([1.17746699, 1.43853994, 1.99209014, 1.60001722, 1.97661075])


```python
# 어떤 axis를 기준으로 sum할지 선택할 수 있다.
# default 는 axis = None -> 모든 요소 전체의 합
np.sum(y, axis=None)
```


8.1847250342209


```python
# axis=0은 행
# axis=1은 열
np.sum(y, axis=0)
```


array([1.17746699, 1.43853994, 1.99209014, 1.60001722, 1.97661075])


```python
np.sum(y, axis=1)
```


array([2.03293046, 3.20025494, 2.95153964])

## cusum (누적 합계)

- 0번째는 기존 y의 0번째 값, 2번째부터는 0번째 + 1번째 원소의 값, 3번째는 누적된 합계 + 3번째 원소의 값... 

- 와 같이 누적된 합이 출력된다.

- 그래프 등을 그릴때 활용하면 유용하다.

```python
np.cumsum(y)
```


array([0.16175123, 0.51047613, 0.77728212, 1.38677025, 2.03293046,
       2.21697074, 3.00854048, 3.74899591, 4.64439346, 5.2331854 ,
       6.06486087, 6.36310617, 7.34793489, 7.44306643, 8.18472503])

# any, all 함수 (boolean)

 - any: 특정 조건을 만족하는 것이 하나라도 있으면 True, 아니면 False

 - all: 모든 원소가 특정 조건을 만족한다면 True, 아니면 False

```python
z = np.random.randn(10)
print("z:\n",z)
```


z:
 [ 1.25430066  1.21295833  0.36602086  0.17307094  0.34133644 -0.23219253
 -0.31665163 -1.89797211  0.58453488  0.79754151]


```python
z > 0
```


array([ True,  True,  True,  True,  True, False, False, False,  True,
        True])


```python
# 모든 z의 원소중 0이상인 값이 1개라도 있으면 True
np.any(z > 0)
```


True


```python
# 모든 z의 원소가 0이 아니면 True
np.all(z != 0)
```


True


```python
np.all(z = 0)
```

# where 함수

 - 조건에 따라 선별적으로 값을 선택 가능

 - e.g) 음수인경우는 0, 나머지는 그대로 값을 쓰는 경우

 ```python

np.where(조건, True일 경우 적용될 값, False일 경우 적용될 값)

```

```python
z = np.random.randn(10)
print("z:\n",z)
```


z:
 [-0.27439924 -0.23866981  1.08032903  0.53438082  1.12337136  0.51202734
 -0.18358531 -0.89482512  0.53332028 -0.36827687]


```python
# 각 원소가 0보다 크다면 생성한 z값을 그대로 사용, 아닌 경우 해당값을 0으로 변경
np.where(z > 0, z, 0)
```


array([0.        , 0.        , 1.08032903, 0.53438082, 1.12337136,
       0.51202734, 0.        , 0.        , 0.53332028, 0.        ])

**조건문이나 loop를 사용하지 않아도 효율적으로 값의 변경등이 가능하다.**

