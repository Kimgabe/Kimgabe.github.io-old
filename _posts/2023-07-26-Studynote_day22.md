---
layout : single
title:  "[스터디노트] Day22 자료구조/알고리즘"
categories: [ds19_Bootcamp, 자료구조/알고리즘, Study Note]
tag: 스터디노트
header :
    teaser : "/assets/img/studynote/studynote_day22.png"
---


# 💡공부한 내용

---

- 최솟값 알고리즘
- 최빈값 알고리즘
- 근삿값 알고리즘
- 평균 알고리즘
- 재귀 알고리즘

# 📝 오늘의 하이라이트

---

<aside>
💡 복습을 위해 예제 코드는 가급적 강의에서 들은 내용이 아닌 직접 만들어서 작성

</aside>

- 최솟값 : 주어진 데이터 집합에서 가장 작은 값을 찾는 것
    - 데이터의 정렬, 검색 등 데이터 분석에서 가장 중요한 기본 연산방법 중 하나
    - 보통 리스트에 담겨있는 데이터(또는 dataframe등)에서 가장 작은 값을 찾는다.
    
    ```python
    values = [5, 3, 9, 1, 4]  # 비교할 값들
    
    # 내장 함수 사용
    min_value_builtin = min(values)  # min 함수로 최솟값 찾기
    
    # 직접 구현
    min_value_custom = values[0]  # 초기 최솟값 설정
    for value in values:
        if value < min_value_custom:
            min_value_custom = value  # 더 작은 값이 발견되면 최솟값 업데이트
    ```
    
- 최빈값 : 데이터 집합에서 가장 자주 등장하는 값을 찾는 것
    - 데이터 집합 중에 가장 대표적인 데이터가 무엇인지 파악하기 위해 사용
    - 주로 통계적 분석 EDA등을 할때 활용
    
    ```python
    from collections import Counter  # Counter 클래스 임포트
    
    values = [1, 2, 2, 3, 3, 3]  # 비교할 값들
    
    # 내장 함수 사용
    mode_builtin = max(values, key=values.count)  # count로 빈도 찾고, max로 최빈값 찾기
    
    # 직접 구현
    counts = Counter(values)                   # 각 값의 빈도 계산
    mode_custom = max(counts, key=counts.get)  # 빈도가 가장 높은 값 찾기
    ```
    
- 근삿값 : 데이터 집합중 주어진 값에 가장 가까운값을 찾는 것
    - 주로 실수값의 반올림이나 근사 계산에 사용하며, 수학적인 계산을 하거나 딥러닝을 할때 그래픽 처리 등에 활용(아직은 머나먼 이야기..😂)
    
    ```python
    def approximate(value, target):
        return min(range(target-10, target+11), key=lambda x: abs(x-value))  # abs를 사용해 근삿값 찾기
    ```
    
- 평균 : 데이터 집합의 합을 데이터 개수로 나눈 값(수학적 평균의 정의와 동일)
    - EDA등을 할때 데이터 집합의 경향을 파악할 수 있음
    - 주로 통계, 예측, 분석 업무를 할때 빈번하게 사용하는 개념
    
    ```python
    values = [1, 2, 3, 4, 5]
    
    # 내장 함수 사용
    average_builtin = sum(values) / len(values)  # sum과 len을 사용해 평균 구하기
    
    # 직접 구현
    total = 0
    for value in values:
        total += value
    average_custom = total / len(values)  # 합계와 개수를 이용해 평균 구하기
    ```
    
- 재귀 : “함수가 자기 자신을 다시 호출하는 프로그래밍 패턴” 을 의미하며, 종료 조건이 만족될 때 까지 함수가 계속 자기 자신을 호출하여 작동
    - 복잡한 문제를 작은 하위 단위로 분할해서 해결할 수 있는 방법이므로 복잡한 문제 해결에 주로 적용
    - 동일한 문제를 풀때 반복문을 사용한 코드보다 간결하고 이해가 쉬울 수 있음
    - 문제를 동일한 형태의 작은 문제로 나누고 사전에 정의한 재귀함수를 작은 문제에 각각 적용한 뒤 그 결과를 합쳐 문제를 해결
    - 피보나치 수열, 하노이 탑, 트리 순회 등의 문제 풀이에 활용
    
    ```python
    def factorial(n):
        if n == 1:
            return 1           # 기저 조건 (재귀 종료 조건)
        return n * factorial(n-1)  # 재귀 호출로 팩토리얼 계산
    ```
    
    ⚠️ 재귀는 종료조건이 없으면 무한 호출에 빠질 수 있으므로 반드시 종료조건을 설정해야 함
    
    ⚠️ 많은 재귀 호출은 호출 스택이 넘치는 스택 오버플로우(메모리 초과로 bust 되는 현상) 를 일으킬 수 있으니 유의해서 사용해야 함
    
    ⚠️ 경우에 따라 반복문을 사용하는게 더 효율적일 수 있으니 적절하게 적용해야 함
    

# ✍️ 오늘의 혼잣말

---

- 공부하다 근본적인 의문이 들었다 . 재귀 함수도 결국 안에 구현된 건 반복문인데 재귀 함수랑 반복문에 무슨 차이가 있는거지?
    - 단순하게 생각하면 둘은 유사할 수 있으나 구조나 작동원리, 사용방법에 차이가 있음
    1. **구조와 가독성**:
        - **재귀 함수**: 함수가 자기 자신을 호출하며 작동함. 즉, 복잡한 문제를 간단하고 명확한 방식으로 나타낼 수 있음
        - **반복문**: **`for`** 또는 **`while`**과 같은 구문을 사용하여 `특정 작업을 반복`하게 하는 방식. 복잡한 문제를 해결할 때 코드가 길어지고 복잡해질 수 있음
    2. **성능**:
        - **재귀 함수**:
            - 함수를 호출할 때 마다 메모리에 함수의 상태가 누적되어 계속 저장되어 메모리 사용량이 증가하고 이는 스택 오버플로우를 유발할 수 있음.
            - 또한 함수를 호출할때마다 추가적인 시간이 소요되므로 입력값이 큰 경우 성능 이슈가 발생할 수 있음
        - **반복문**: 재귀 함수에 비해 일반적으로 더 효율적. 함수 호출을 하지 않으므로 메모리나 시간적인 부분에서 부하가 되는 경우가 드물기 때문. 대체로 동일작업을 수행하는 경우 재귀보다 반복문이 더 빠른 이유.
    3. **사용하는 경우**:
        - **재귀 함수**: 재귀 함수는 특정 알고리즘, 특히 트리 탐색이나 분할 정복 알고리즘과 같은 복잡한 구조에서 유용하게 사용. 특별히 복잡한 문제를 분해하여 간단한 형태로 표현할 수 있는 경우에 적합 하지만 일반적인 상황에서는 메모리 사용량과 성능 문제로 인해 적극적으로 사용되지는 않음.
        - 반복문 : 일상적인 프로그래밍 작업에서 주로 사용되는 구조. 반복적인 작업을 처리할 때 흔히 사용되며, 재귀 함수보다 직관적이고 효율적일 수 있음.
        - 팩토리얼 구현을 통해 보는 둘의 차이