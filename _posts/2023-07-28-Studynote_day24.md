---
layout : single
title:  "[스터디노트] Day24 자료구조/알고리즘"
categories: [DS17_Bootcamp, 자료구조/알고리즘]
tag: [스터디노트, 문제풀이, 검색알고리즘, 정렬알고리즘, 재귀]
header :
    teaser : "/assets/img/studynote/studynote_day24.png"
---


# 💡공부한 내용

---

- 검색
    - 선형검색
    - 이진검색
- 순위
- 정렬
    - 버블정렬
    - 삽입정렬
    - 선택정렬
    - 병합정렬
- 최대값/최소값/최빈값/근삿값/평균
- 재귀

# 📝 오늘의 하이라이트

---

<aside>
💡 복습을 위해 예제 코드는 가급적 강의에서 들은 내용이 아닌 직접 만들어서 작성

</aside>

### 선형검색

> 사용자가 입력한 숫자를 검색하기
> - 선형검색은 순차적탐색(sequential search)로 단순하게 리스트를 처음부터 끝까지 순차적으로 하나씩 탐색하는 방식
> - 검색 모듈은 선형 검색 알고리즘을 활용
> - 리스트는 1부터 20까지의 정수중에서 난수 10개를 이용
> - 검색 과정을 로그로 출력하기
> - 검색에 성공하면 해당 정수의 인덱스를 출력하고, 검색 결과가 없다면 -1출력하기

```python
import random

def generate_random_list():
    # 1부터 20까지의 숫자 중 10개를 중복 없이 추출하여 리스트 생성
    return random.sample(range(1, 21), 10)

def linear_search(num_list, target):
    for index, num in enumerate(num_list):
        # 현재 탐색 중인 숫자 출력
        print(f"현재 {num} 확인")
        
        # 탐색한 숫자가 타겟과 일치하는지 확인
        if num == target:
            return index
    # 숫자를 찾지 못했을 때
    return -1

def search_module():
    # 난수 리스트 생성
    num_list = generate_random_list()
    print(f"생성된 난수 리스트: {num_list}")
    
    # 사용자로부터 검색할 숫자 입력받기
    target = int(input("검색할 숫자를 입력하세요 (1-20): "))
    
    # 선형 검색 수행
    index = linear_search(num_list, target)
    
    # 검색 결과 출력
    if index != -1:
        print(f"{target}는(은) 리스트 내 인덱스 {index} 위치에 있습니다.")
    else:
        print('-1')
        print(f"{target}는(은) 리스트 내에 없습니다.")
        

# 모듈 실행
search_module()
```

```python
생성된 난수 리스트: [2, 1, 8, 14, 19, 15, 9, 20, 11, 13]
검색할 숫자를 입력하세요 (1-20): 8
현재 2 확인
현재 1 확인
현재 8 확인
8는(은) 리스트 내 인덱스 2 위치에 있습니다.
```

### 이진검색

> **사용자가 입력한 숫자를 이진검색으로 검색하기**
> 
> 
> • 이진 검색 : 리스트의 중간값을 기준으로 타겟 값과 대소관계를 비교하며 탐색 범위를 절반씩 줄여나가며 검색하는 알고리즘
> 

```python
def binary_search():
    # 사용자로부터 검색할 숫자 입력받기
    target_list = [1,2,4,6,7,8,10,11,13,15,16,17,20,21,23,24,27,28]
    print(target_list)
    target = int(input("위 리스트 중 검색할 숫자를 입력하세요: "))
    
    # 시작점과 끝점을 초기화
    start, end = 0, len(target_list) - 1
    
    while start <= end:
        # 중간점 계산
        mid = (start + end) // 2

        # 중간점의 값과 타겟을 비교
        if target_list[mid] == target:
            # 값을 찾았을 때 로그 출력
            print(f"{target}를 {mid} 인덱스에서 발견!")
            return mid
        elif target_list[mid] < target:
            # 타겟이 중간점의 값보다 클 때 로그 출력 및 시작점 변경
            print(f"{mid} 인덱스의 값 {target_list[mid]} < {target}. 오른쪽에서 계속 검색!")
            start = mid + 1
        else:
            # 타겟이 중간점의 값보다 작을 때 로그 출력 및 끝점 변경
            print(f"{mid} 인덱스의 값 {target_list[mid]} > {target}. 왼쪽에서 계속 검색!")
            end = mid - 1

    # 값을 찾지 못했을 때 로그 출력
    print(f"{target} 값은 리스트에 없습니다.")
    return -1

# 테스트
binary_search()
```

```python
[1, 2, 4, 6, 7, 8, 10, 11, 13, 15, 16, 17, 20, 21, 23, 24, 27, 28]
위 리스트 중 검색할 숫자를 입력하세요: 17
8 인덱스의 값 13 < 17. 오른쪽에서 계속 검색!
13 인덱스의 값 21 > 17. 왼쪽에서 계속 검색!
10 인덱스의 값 16 < 17. 오른쪽에서 계속 검색!
17를 11 인덱스에서 발견!
11
```

### 순위

> **아이템 순위를 출력하고 순위에 따라 아이템을 정렬하기**
> 
> - 순위 알고리즘을 이용해서 구현하기
>     - 주어진 리스트의 각 원소를 나머지 모든 원소와 비교하여 그 원소의 순위를 결정하는 방법. 원소가 비교 대상보다 크면 해당 원소의 순위 값을 증가시키고, 비교 대상이 크면 비교 대상의 순위 값을 증가하는 방식
> - 리스트는 50 ~ 100 사이 난수 20개를 이용
> - 생성된 난수와 순위 리스트 출력해야 함

```python
import random  # 난수 생성을 위한 모듈 호출

# 주어진 리스트의 원소에 대해 순위를 결정하는 함수
def rank_algorithm(num_list):
    # 각 원소의 순위를 저장할 리스트 초기화 (길이는 num_list와 동일)
    idx_list = [0] * len(num_list)
    
    # 주어진 리스트의 각 원소에 대해
    for i, num1 in enumerate(num_list):
        # 다른 모든 원소와의 비교를 수행
        for j, num2 in enumerate(num_list):
            # 자기 자신과는 비교하지 않음
            if i != j:
                # num1이 num2보다 작을 경우
                if num1 < num2:
                    # num1의 순위 값을 증가
                    idx_list[i] += 1
                # 그렇지 않을 경우 (num1이 num2보다 크거나 같을 경우)
                else:
                    # num2의 순위 값을 증가
                    idx_list[j] += 1
    
    # 최종 결정된 순위 리스트 반환
    return idx_list

# 메인 실행 함수
def rank_module():
    # 50~100 사이의 난수 20개 생성하여 num_list에 저장
    num_list = [random.randint(50, 100) for _ in range(20)]
    
    # num_list에 대해 순위 알고리즘 적용하여 순위 리스트 생성
    rank_list = rank_algorithm(num_list)
    
    # 생성된 난수 리스트 출력
    print("생성된 난수 리스트:", num_list)
    # 생성된 순위 리스트 출력
    print("생성된 순위 리스트:", rank_list)
    
    # num_list의 각 원소와 해당 원소의 순위를 함께 출력
    for num, rank in zip(num_list, rank_list):
        print(f"(num:{num} rank:{rank+1})")

# rank_module 함수 실행
rank_module()
```

```python
생성된 난수 리스트: [62, 99, 52, 89, 67, 96, 86, 65, 95, 98, 60, 76, 57, 50, 97, 57, 72, 73, 77, 94]
생성된 순위 리스트: [28, 0, 36, 12, 24, 6, 14, 26, 8, 2, 30, 18, 33, 38, 4, 33, 22, 20, 16, 10]
(num:62 rank:29)
(num:99 rank:1)
(num:52 rank:37)
(num:89 rank:13)
(num:67 rank:25)
(num:96 rank:7)
(num:86 rank:15)
(num:65 rank:27)
(num:95 rank:9)
(num:98 rank:3)
(num:60 rank:31)
(num:76 rank:19)
(num:57 rank:34)
(num:50 rank:39)
(num:97 rank:5)
(num:57 rank:34)
(num:72 rank:23)
(num:73 rank:21)
(num:77 rank:17)
(num:94 rank:11)
```

### 버블정렬

> **버블정렬로 숫자로 이뤄진 리스트 정렬하기** 
> 
> • **버블정렬** : 인접한 두개의 원소를 비교해 조건에 맞지 않는 순서로 되어 있을 경우 원소를 교환하는 방법으로 정렬하는 알고리즘. 가장 큰 원소가 맨끝으로 이동하는 것을 반복하며 정렬
> 

```python
# 버블 정렬 알고리즘으로 오름차순 정렬 함수
def bubble_sort_asc(nums):
    n = len(nums)  # nums의 길이를 구함
    
    print("오름차순 정렬 과정:")

    # 첫 번째 원소부터 마지막 원소까지 반복
    for i in range(n):
        # 인접한 원소들과 비교하기 위해 반복
        for j in range(0, n-i-1):
            # 현재 원소와 다음 원소를 출력
            print(f"Comparing {nums[j]} with {nums[j+1]}")
            # 현재 원소가 다음 원소보다 크면
            if nums[j] > nums[j+1]:
                # 두 원소를 교환
                nums[j], nums[j+1] = nums[j+1], nums[j]
        print(nums)  # 정렬 과정 출력
        print('-'*60)

    return nums  # 정렬된 리스트 반환

# 버블 정렬 알고리즘으로 내림차순 정렬 함수
def bubble_sort_desc(nums):
    n = len(nums)  # nums의 길이를 구함
    
    print("내림차순 정렬 과정:")

    # 첫 번째 원소부터 마지막 원소까지 반복
    for i in range(n):
        # 인접한 원소들과 비교하기 위해 반복
        for j in range(0, n-i-1):
            # 현재 원소와 다음 원소를 출력
            print(f"Comparing {nums[j]} with {nums[j+1]}")
            # 현재 원소가 다음 원소보다 작으면
            if nums[j] < nums[j+1]:
                # 두 원소를 교환
                nums[j], nums[j+1] = nums[j+1], nums[j]
        print(nums)  # 정렬 과정 출력
        print('-'*60)

    return nums  # 정렬된 리스트 반환

# 정렬 실행 함수
def execute_sorting():
    nums = [10, 4, 1, 13, 11, 16, 19, 14, 6, 5]
    print("not sorted nums:", nums,"\n")
    
    sorted_asc = bubble_sort_asc(nums.copy())  # 오름차순 정렬 (원본 리스트 복사하여 사용)
    print("sorted nums by ASC:", sorted_asc,"\n")
    
    sorted_desc = bubble_sort_desc(nums.copy())  # 내림차순 정렬 (원본 리스트 복사하여 사용)
    print("\n","sorted nums by DESC:", sorted_desc)

# 실행
execute_sorting()
```

```python
not sorted nums: [10, 4, 1, 13, 11, 16, 19, 14, 6, 5] 

오름차순 정렬 과정:
Comparing 10 with 4
Comparing 10 with 1
Comparing 10 with 13
Comparing 13 with 11
Comparing 13 with 16
Comparing 16 with 19
Comparing 19 with 14
Comparing 19 with 6
Comparing 19 with 5
[4, 1, 10, 11, 13, 16, 14, 6, 5, 19]
------------------------------------------------------------
Comparing 4 with 1
Comparing 4 with 10
Comparing 10 with 11
Comparing 11 with 13
Comparing 13 with 16
Comparing 16 with 14
Comparing 16 with 6
Comparing 16 with 5
[1, 4, 10, 11, 13, 14, 6, 5, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
Comparing 4 with 10
Comparing 10 with 11
Comparing 11 with 13
Comparing 13 with 14
Comparing 14 with 6
Comparing 14 with 5
[1, 4, 10, 11, 13, 6, 5, 14, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
Comparing 4 with 10
Comparing 10 with 11
Comparing 11 with 13
Comparing 13 with 6
Comparing 13 with 5
[1, 4, 10, 11, 6, 5, 13, 14, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
Comparing 4 with 10
Comparing 10 with 11
Comparing 11 with 6
Comparing 11 with 5
[1, 4, 10, 6, 5, 11, 13, 14, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
Comparing 4 with 10
Comparing 10 with 6
Comparing 10 with 5
[1, 4, 6, 5, 10, 11, 13, 14, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
Comparing 4 with 6
Comparing 6 with 5
[1, 4, 5, 6, 10, 11, 13, 14, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
Comparing 4 with 5
[1, 4, 5, 6, 10, 11, 13, 14, 16, 19]
------------------------------------------------------------
Comparing 1 with 4
[1, 4, 5, 6, 10, 11, 13, 14, 16, 19]
------------------------------------------------------------
[1, 4, 5, 6, 10, 11, 13, 14, 16, 19]
------------------------------------------------------------
sorted nums by ASC: [1, 4, 5, 6, 10, 11, 13, 14, 16, 19] 

내림차순 정렬 과정:
Comparing 10 with 4
Comparing 4 with 1
Comparing 1 with 13
Comparing 1 with 11
Comparing 1 with 16
Comparing 1 with 19
Comparing 1 with 14
Comparing 1 with 6
Comparing 1 with 5
[10, 4, 13, 11, 16, 19, 14, 6, 5, 1]
------------------------------------------------------------
Comparing 10 with 4
Comparing 4 with 13
Comparing 4 with 11
Comparing 4 with 16
Comparing 4 with 19
Comparing 4 with 14
Comparing 4 with 6
Comparing 4 with 5
[10, 13, 11, 16, 19, 14, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 10 with 13
Comparing 10 with 11
Comparing 10 with 16
Comparing 10 with 19
Comparing 10 with 14
Comparing 10 with 6
Comparing 6 with 5
[13, 11, 16, 19, 14, 10, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 13 with 11
Comparing 11 with 16
Comparing 11 with 19
Comparing 11 with 14
Comparing 11 with 10
Comparing 10 with 6
[13, 16, 19, 14, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 13 with 16
Comparing 13 with 19
Comparing 13 with 14
Comparing 13 with 11
Comparing 11 with 10
[16, 19, 14, 13, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 16 with 19
Comparing 16 with 14
Comparing 14 with 13
Comparing 13 with 11
[19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 19 with 16
Comparing 16 with 14
Comparing 14 with 13
[19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 19 with 16
Comparing 16 with 14
[19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------
Comparing 19 with 16
[19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------
[19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
------------------------------------------------------------

 sorted nums by DESC: [19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
```

### 삽입정렬

> **삽입정렬 알고리즘으로 숫자로 이뤄진 리스트 정렬하기**
> 
> 
> • **삽입정렬** : 정렬되지 않은 부분의 첫번째 원소를 이미 정렬된 부분의 올바른 위치에 삽입하는 것을 반복해 정렬하는 알고리즘
> 

```python
def insertion_sort(nums, order="asc"):
    # 길이 정보 추출
    n = len(nums)

    for i in range(1, n):  # 1부터 시작하여 전체 리스트를 순회
        key = nums[i]  # 현재 원소를 key 값으로 저장
        j = i-1

        # 오름차순 정렬
        if order == "asc":
            # key 값보다 앞쪽의 원소와 비교
            while j >= 0 and key < nums[j]:  # 앞쪽 원소가 key보다 큰 경우
                print(f"Comparing {key} with {nums[j]}")
                nums[j + 1] = nums[j]  # 앞쪽 원소를 뒤로 이동
                j -= 1
        # 내림차순 정렬
        else:
            # key 값보다 앞쪽의 원소와 비교
            while j >= 0 and key > nums[j]:  # 앞쪽 원소가 key보다 작은 경우
                print(f"Comparing {key} with {nums[j]}")
                nums[j + 1] = nums[j]  # 앞쪽 원소를 뒤로 이동
                j -= 1

        nums[j + 1] = key  # key 값을 올바른 위치에 삽입

        # 정렬 과정 출력
        print('-' * 60)
        print("\n", f"step {i}: {nums}")

    return nums

def execute_sort():
    nums = [10, 4, 1, 13, 11, 16, 19, 14, 6, 5]
    print(f"not sorted nums : {nums}")

    sorted_asc = insertion_sort(nums.copy(), "asc")
    print("\n", f"sorted nums by ASC: {sorted_asc}")

    sorted_desc = insertion_sort(nums.copy(), "desc")
    print(f"sorted nums by DESC: {sorted_desc}")

execute_sort()
```

```python
not sorted nums : [10, 4, 1, 13, 11, 16, 19, 14, 6, 5]
Comparing 4 with 10
------------------------------------------------------------

 step 1: [4, 10, 1, 13, 11, 16, 19, 14, 6, 5]
Comparing 1 with 10
Comparing 1 with 4
------------------------------------------------------------

 step 2: [1, 4, 10, 13, 11, 16, 19, 14, 6, 5]
------------------------------------------------------------

 step 3: [1, 4, 10, 13, 11, 16, 19, 14, 6, 5]
Comparing 11 with 13
------------------------------------------------------------

 step 4: [1, 4, 10, 11, 13, 16, 19, 14, 6, 5]
------------------------------------------------------------

 step 5: [1, 4, 10, 11, 13, 16, 19, 14, 6, 5]
------------------------------------------------------------

 step 6: [1, 4, 10, 11, 13, 16, 19, 14, 6, 5]
Comparing 14 with 19
Comparing 14 with 16
------------------------------------------------------------

 step 7: [1, 4, 10, 11, 13, 14, 16, 19, 6, 5]
Comparing 6 with 19
Comparing 6 with 16
Comparing 6 with 14
Comparing 6 with 13
Comparing 6 with 11
Comparing 6 with 10
------------------------------------------------------------

 step 8: [1, 4, 6, 10, 11, 13, 14, 16, 19, 5]
Comparing 5 with 19
Comparing 5 with 16
Comparing 5 with 14
Comparing 5 with 13
Comparing 5 with 11
Comparing 5 with 10
Comparing 5 with 6
------------------------------------------------------------

 step 9: [1, 4, 5, 6, 10, 11, 13, 14, 16, 19]

 sorted nums by ASC: [1, 4, 5, 6, 10, 11, 13, 14, 16, 19]
------------------------------------------------------------

 step 1: [10, 4, 1, 13, 11, 16, 19, 14, 6, 5]
------------------------------------------------------------

 step 2: [10, 4, 1, 13, 11, 16, 19, 14, 6, 5]
Comparing 13 with 1
Comparing 13 with 4
Comparing 13 with 10
------------------------------------------------------------

 step 3: [13, 10, 4, 1, 11, 16, 19, 14, 6, 5]
Comparing 11 with 1
Comparing 11 with 4
Comparing 11 with 10
------------------------------------------------------------

 step 4: [13, 11, 10, 4, 1, 16, 19, 14, 6, 5]
Comparing 16 with 1
Comparing 16 with 4
Comparing 16 with 10
Comparing 16 with 11
Comparing 16 with 13
------------------------------------------------------------

 step 5: [16, 13, 11, 10, 4, 1, 19, 14, 6, 5]
Comparing 19 with 1
Comparing 19 with 4
Comparing 19 with 10
Comparing 19 with 11
Comparing 19 with 13
Comparing 19 with 16
------------------------------------------------------------

 step 6: [19, 16, 13, 11, 10, 4, 1, 14, 6, 5]
Comparing 14 with 1
Comparing 14 with 4
Comparing 14 with 10
Comparing 14 with 11
Comparing 14 with 13
------------------------------------------------------------

 step 7: [19, 16, 14, 13, 11, 10, 4, 1, 6, 5]
Comparing 6 with 1
Comparing 6 with 4
------------------------------------------------------------

 step 8: [19, 16, 14, 13, 11, 10, 6, 4, 1, 5]
Comparing 5 with 1
Comparing 5 with 4
------------------------------------------------------------

 step 9: [19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
sorted nums by DESC: [19, 16, 14, 13, 11, 10, 6, 5, 4, 1]
```

### 선택정렬

> **선택정렬 알고리즘으로 숫자로 이뤄진 리스트 정렬하기**
> 
> 
> • **선택정렬** : 배열에서 최소값을 찾아 배열의 맨 앞에 위치한 값과 교환하는 방식으로 정렬하는 알고리즘
> 

```python
def merge_sort(nums):
    """리스트를 병합 정렬로 정렬하는 함수"""
    
    # 길이 확인 후, 1이하면 그대로 반환
    if len(nums) <= 1:
        return nums

    # 리스트 중앙 인덱스 계산
    mid = len(nums) // 2
    # 중앙 인덱스를 기준으로 왼쪽 리스트 추출
    left = nums[:mid]
    # 중앙 인덱스를 기준으로 오른쪽 리스트 추출
    right = nums[mid:]

    # 분할된 리스트 출력
    print("\n",f"분할: {nums} -> {left} , {right}")

    # 왼쪽 리스트 병합 정렬
    left = merge_sort(left)
    # 오른쪽 리스트 병합 정렬
    right = merge_sort(right)

    # 두 리스트 병합 후 반환
    return merge(left, right)

def merge(left, right):
    """두 리스트를 병합하여 정렬된 리스트 반환"""
    
    # 결과를 담을 리스트 초기화
    merged = []
    left_index, right_index = 0, 0

    # 두 리스트의 원소를 순서대로 비교하며 작은 값을 merged에 추가
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1

    # 왼쪽 리스트의 남은 원소들을 merged에 추가
    while left_index < len(left):
        merged.append(left[left_index])
        left_index += 1

    # 오른쪽 리스트의 남은 원소들을 merged에 추가
    while right_index < len(right):
        merged.append(right[right_index])
        right_index += 1

    # 병합된 리스트 결과 출력
    print("\n", f"{left}와 {right} 병합 -> {merged}")
    
    return merged

def merge_sort_result(nums, order='asc'):
    """리스트 정렬 함수"""
    
    # 경계선 출력
    print('-'*120)
    # 정렬 전 리스트 출력
    print("정렬 전 :", nums)
    # 경계선 출력
    print('-'*120)

    # 정렬 방식에 따라 오름차순 또는 내림차순으로 정렬
    if order == 'asc':
        sorted_nums = merge_sort(nums)
        print('-'*120)
        print("오름차순 정렬 결과 :", sorted_nums)
    elif order == 'desc':
        sorted_nums = merge_sort(nums)[::-1]
        print('-'*120)
        print("내림차순 정렬 결과 :", sorted_nums)
    else:
        print("정렬 방식이 올바르지 않습니다!")
    print('-'*120)

# 코드 실행 시작 지점
if __name__ == "__main__":
    nums = [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84]
    merge_sort_result(nums, 'asc')
    merge_sort_result(nums, 'desc')
```

```python
------------------------------------------------------------------------------------------------------------------------
정렬 전 : [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84]
------------------------------------------------------------------------------------------------------------------------

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] , [54, 56, 94, 49, 25, 28, 88, 50, 41, 84]

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] -> [24, 62, 81, 38, 51] , [10, 85, 76, 71, 91]

 분할: [24, 62, 81, 38, 51] -> [24, 62] , [81, 38, 51]

 분할: [24, 62] -> [24] , [62]

 [24]와 [62] 병합 -> [24, 62]

 분할: [81, 38, 51] -> [81] , [38, 51]

 분할: [38, 51] -> [38] , [51]

 [38]와 [51] 병합 -> [38, 51]

 [81]와 [38, 51] 병합 -> [38, 51, 81]

 [24, 62]와 [38, 51, 81] 병합 -> [24, 38, 51, 62, 81]

 분할: [10, 85, 76, 71, 91] -> [10, 85] , [76, 71, 91]

 분할: [10, 85] -> [10] , [85]

 [10]와 [85] 병합 -> [10, 85]

 분할: [76, 71, 91] -> [76] , [71, 91]

 분할: [71, 91] -> [71] , [91]

 [71]와 [91] 병합 -> [71, 91]

 [76]와 [71, 91] 병합 -> [71, 76, 91]

 [10, 85]와 [71, 76, 91] 병합 -> [10, 71, 76, 85, 91]

 [24, 38, 51, 62, 81]와 [10, 71, 76, 85, 91] 병합 -> [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]

 분할: [54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [54, 56, 94, 49, 25] , [28, 88, 50, 41, 84]

 분할: [54, 56, 94, 49, 25] -> [54, 56] , [94, 49, 25]

 분할: [54, 56] -> [54] , [56]

 [54]와 [56] 병합 -> [54, 56]

 분할: [94, 49, 25] -> [94] , [49, 25]

 분할: [49, 25] -> [49] , [25]

 [49]와 [25] 병합 -> [25, 49]

 [94]와 [25, 49] 병합 -> [25, 49, 94]

 [54, 56]와 [25, 49, 94] 병합 -> [25, 49, 54, 56, 94]

 분할: [28, 88, 50, 41, 84] -> [28, 88] , [50, 41, 84]

 분할: [28, 88] -> [28] , [88]

 [28]와 [88] 병합 -> [28, 88]

 분할: [50, 41, 84] -> [50] , [41, 84]

 분할: [41, 84] -> [41] , [84]

 [41]와 [84] 병합 -> [41, 84]

 [50]와 [41, 84] 병합 -> [41, 50, 84]

 [28, 88]와 [41, 50, 84] 병합 -> [28, 41, 50, 84, 88]

 [25, 49, 54, 56, 94]와 [28, 41, 50, 84, 88] 병합 -> [25, 28, 41, 49, 50, 54, 56, 84, 88, 94]

 [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]와 [25, 28, 41, 49, 50, 54, 56, 84, 88, 94] 병합 -> [10, 24, 25, 28, 38, 41, 49, 50, 51, 54, 56, 62, 71, 76, 81, 84, 85, 88, 91, 94]
------------------------------------------------------------------------------------------------------------------------
오름차순 정렬 결과 : [10, 24, 25, 28, 38, 41, 49, 50, 51, 54, 56, 62, 71, 76, 81, 84, 85, 88, 91, 94]
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
정렬 전 : [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84]
------------------------------------------------------------------------------------------------------------------------

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] , [54, 56, 94, 49, 25, 28, 88, 50, 41, 84]

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] -> [24, 62, 81, 38, 51] , [10, 85, 76, 71, 91]

 분할: [24, 62, 81, 38, 51] -> [24, 62] , [81, 38, 51]

 분할: [24, 62] -> [24] , [62]

 [24]와 [62] 병합 -> [24, 62]

 분할: [81, 38, 51] -> [81] , [38, 51]

 분할: [38, 51] -> [38] , [51]

 [38]와 [51] 병합 -> [38, 51]

 [81]와 [38, 51] 병합 -> [38, 51, 81]

 [24, 62]와 [38, 51, 81] 병합 -> [24, 38, 51, 62, 81]

 분할: [10, 85, 76, 71, 91] -> [10, 85] , [76, 71, 91]

 분할: [10, 85] -> [10] , [85]

 [10]와 [85] 병합 -> [10, 85]

 분할: [76, 71, 91] -> [76] , [71, 91]

 분할: [71, 91] -> [71] , [91]

 [71]와 [91] 병합 -> [71, 91]

 [76]와 [71, 91] 병합 -> [71, 76, 91]

 [10, 85]와 [71, 76, 91] 병합 -> [10, 71, 76, 85, 91]

 [24, 38, 51, 62, 81]와 [10, 71, 76, 85, 91] 병합 -> [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]

 분할: [54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [54, 56, 94, 49, 25] , [28, 88, 50, 41, 84]

 분할: [54, 56, 94, 49, 25] -> [54, 56] , [94, 49, 25]

 분할: [54, 56] -> [54] , [56]

 [54]와 [56] 병합 -> [54, 56]

 분할: [94, 49, 25] -> [94] , [49, 25]

 분할: [49, 25] -> [49] , [25]

 [49]와 [25] 병합 -> [25, 49]

 [94]와 [25, 49] 병합 -> [25, 49, 94]

 [54, 56]와 [25, 49, 94] 병합 -> [25, 49, 54, 56, 94]

 분할: [28, 88, 50, 41, 84] -> [28, 88] , [50, 41, 84]

 분할: [28, 88] -> [28] , [88]

 [28]와 [88] 병합 -> [28, 88]

 분할: [50, 41, 84] -> [50] , [41, 84]

 분할: [41, 84] -> [41] , [84]

 [41]와 [84] 병합 -> [41, 84]

 [50]와 [41, 84] 병합 -> [41, 50, 84]

 [28, 88]와 [41, 50, 84] 병합 -> [28, 41, 50, 84, 88]

 [25, 49, 54, 56, 94]와 [28, 41, 50, 84, 88] 병합 -> [25, 28, 41, 49, 50, 54, 56, 84, 88, 94]

 [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]와 [25, 28, 41, 49, 50, 54, 56, 84, 88, 94] 병합 -> [10, 24, 25, 28, 38, 41, 49, 50, 51, 54, 56, 62, 71, 76, 81, 84, 85, 88, 91, 94]
------------------------------------------------------------------------------------------------------------------------
내림차순 정렬 결과 : [94, 91, 88, 85, 84, 81, 76, 71, 62, 56, 54, 51, 50, 49, 41, 38, 28, 25, 24, 10]
------------------------------------------------------------------------------------------------------------------------
```

### 병합정렬

> **병합정렬 알고리즘으로 숫자로 이뤄진 리스트 정렬하기**
> 
> - **병합정렬** : 분할정복(divide and conquer)방법을 통해 리스트를 정렬하는 알고리즘
>     1. 리스트 길이가 1또는 0이면 이미 정렬된 것으로 간주
>     2. 그렇지 않은 경우 리스트를 반으로 split
>     3. 각각의 리스트를 재귀적으로 병합 정렬
>     4. 각각 정렬된 2개의 리스트를 병합

```python
def merge_sort(nums):
    """리스트를 병합 정렬로 정렬하는 함수"""
    # 리스트의 길이가 1 또는 0이면 이미 정렬된 것으로 간주하고 반환
    if len(nums) <= 1:
        return nums

    # 리스트를 두 부분으로 분할
    mid = len(nums) // 2  # 중앙 인덱스 계산
    left = nums[:mid]     # 중앙을 기준으로 왼쪽 부분
    right = nums[mid:]    # 중앙을 기준으로 오른쪽 부분

    print("\n",f"분할: {nums} -> {left} , {right}")  # 분할 과정 출력

    # 왼쪽, 오른쪽 부분을 재귀적으로 병합 정렬
    left = merge_sort(left)
    right = merge_sort(right)

    # 두 부분을 병합해 정렬된 리스트 반환
    return merge(left, right)

def merge(left, right):
    """두 리스트를 병합하여 정렬된 리스트 반환"""
    merged = []
    left_index, right_index = 0, 0

    # 두 리스트의 원소를 비교해가며 작은 값을 결과 리스트에 추가
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1

    # 왼쪽 리스트의 남은 원소를 결과 리스트에 추가
    while left_index < len(left):
        merged.append(left[left_index])
        left_index += 1

    # 오른쪽 리스트의 남은 원소를 결과 리스트에 추가
    while right_index < len(right):
        merged.append(right[right_index])
        right_index += 1

    # 병합된 리스트 출력
    print("\n", f"{left}와 {right} 병합 -> {merged}")
    return merged

def merge_sort_result(nums, order='asc'):
    """리스트 정렬 함수"""
    print('-'*120)
    print("정렬 전 :", nums)
    print('-'*120)

    if order == 'asc':
        sorted_nums = merge_sort(nums)
        print('-'*120)
        print("오름차순 정렬 결과 :", sorted_nums)
    elif order == 'desc':
        sorted_nums = merge_sort(nums)[::-1]
        print('-'*120)
        print("내림차순 정렬 결과 :", sorted_nums)
    else:
        print("정렬 방식이 올바르지 않습니다!")
    print('-'*120)

# 실행
if __name__ == "__main__":
    nums = [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84]
    merge_sort_result(nums, 'asc')
    merge_sort_result(nums, 'desc')
```

```python
------------------------------------------------------------------------------------------------------------------------
정렬 전 : [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84]
------------------------------------------------------------------------------------------------------------------------

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] , [54, 56, 94, 49, 25, 28, 88, 50, 41, 84]

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] -> [24, 62, 81, 38, 51] , [10, 85, 76, 71, 91]

 분할: [24, 62, 81, 38, 51] -> [24, 62] , [81, 38, 51]

 분할: [24, 62] -> [24] , [62]

 [24]와 [62] 병합 -> [24, 62]

 분할: [81, 38, 51] -> [81] , [38, 51]

 분할: [38, 51] -> [38] , [51]

 [38]와 [51] 병합 -> [38, 51]

 [81]와 [38, 51] 병합 -> [38, 51, 81]

 [24, 62]와 [38, 51, 81] 병합 -> [24, 38, 51, 62, 81]

 분할: [10, 85, 76, 71, 91] -> [10, 85] , [76, 71, 91]

 분할: [10, 85] -> [10] , [85]

 [10]와 [85] 병합 -> [10, 85]

 분할: [76, 71, 91] -> [76] , [71, 91]

 분할: [71, 91] -> [71] , [91]

 [71]와 [91] 병합 -> [71, 91]

 [76]와 [71, 91] 병합 -> [71, 76, 91]

 [10, 85]와 [71, 76, 91] 병합 -> [10, 71, 76, 85, 91]

 [24, 38, 51, 62, 81]와 [10, 71, 76, 85, 91] 병합 -> [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]

 분할: [54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [54, 56, 94, 49, 25] , [28, 88, 50, 41, 84]

 분할: [54, 56, 94, 49, 25] -> [54, 56] , [94, 49, 25]

 분할: [54, 56] -> [54] , [56]

 [54]와 [56] 병합 -> [54, 56]

 분할: [94, 49, 25] -> [94] , [49, 25]

 분할: [49, 25] -> [49] , [25]

 [49]와 [25] 병합 -> [25, 49]

 [94]와 [25, 49] 병합 -> [25, 49, 94]

 [54, 56]와 [25, 49, 94] 병합 -> [25, 49, 54, 56, 94]

 분할: [28, 88, 50, 41, 84] -> [28, 88] , [50, 41, 84]

 분할: [28, 88] -> [28] , [88]

 [28]와 [88] 병합 -> [28, 88]

 분할: [50, 41, 84] -> [50] , [41, 84]

 분할: [41, 84] -> [41] , [84]

 [41]와 [84] 병합 -> [41, 84]

 [50]와 [41, 84] 병합 -> [41, 50, 84]

 [28, 88]와 [41, 50, 84] 병합 -> [28, 41, 50, 84, 88]

 [25, 49, 54, 56, 94]와 [28, 41, 50, 84, 88] 병합 -> [25, 28, 41, 49, 50, 54, 56, 84, 88, 94]

 [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]와 [25, 28, 41, 49, 50, 54, 56, 84, 88, 94] 병합 -> [10, 24, 25, 28, 38, 41, 49, 50, 51, 54, 56, 62, 71, 76, 81, 84, 85, 88, 91, 94]
------------------------------------------------------------------------------------------------------------------------
오름차순 정렬 결과 : [10, 24, 25, 28, 38, 41, 49, 50, 51, 54, 56, 62, 71, 76, 81, 84, 85, 88, 91, 94]
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
정렬 전 : [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84]
------------------------------------------------------------------------------------------------------------------------

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91, 54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] , [54, 56, 94, 49, 25, 28, 88, 50, 41, 84]

 분할: [24, 62, 81, 38, 51, 10, 85, 76, 71, 91] -> [24, 62, 81, 38, 51] , [10, 85, 76, 71, 91]

 분할: [24, 62, 81, 38, 51] -> [24, 62] , [81, 38, 51]

 분할: [24, 62] -> [24] , [62]

 [24]와 [62] 병합 -> [24, 62]

 분할: [81, 38, 51] -> [81] , [38, 51]

 분할: [38, 51] -> [38] , [51]

 [38]와 [51] 병합 -> [38, 51]

 [81]와 [38, 51] 병합 -> [38, 51, 81]

 [24, 62]와 [38, 51, 81] 병합 -> [24, 38, 51, 62, 81]

 분할: [10, 85, 76, 71, 91] -> [10, 85] , [76, 71, 91]

 분할: [10, 85] -> [10] , [85]

 [10]와 [85] 병합 -> [10, 85]

 분할: [76, 71, 91] -> [76] , [71, 91]

 분할: [71, 91] -> [71] , [91]

 [71]와 [91] 병합 -> [71, 91]

 [76]와 [71, 91] 병합 -> [71, 76, 91]

 [10, 85]와 [71, 76, 91] 병합 -> [10, 71, 76, 85, 91]

 [24, 38, 51, 62, 81]와 [10, 71, 76, 85, 91] 병합 -> [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]

 분할: [54, 56, 94, 49, 25, 28, 88, 50, 41, 84] -> [54, 56, 94, 49, 25] , [28, 88, 50, 41, 84]

 분할: [54, 56, 94, 49, 25] -> [54, 56] , [94, 49, 25]

 분할: [54, 56] -> [54] , [56]

 [54]와 [56] 병합 -> [54, 56]

 분할: [94, 49, 25] -> [94] , [49, 25]

 분할: [49, 25] -> [49] , [25]

 [49]와 [25] 병합 -> [25, 49]

 [94]와 [25, 49] 병합 -> [25, 49, 94]

 [54, 56]와 [25, 49, 94] 병합 -> [25, 49, 54, 56, 94]

 분할: [28, 88, 50, 41, 84] -> [28, 88] , [50, 41, 84]

 분할: [28, 88] -> [28] , [88]

 [28]와 [88] 병합 -> [28, 88]

 분할: [50, 41, 84] -> [50] , [41, 84]

 분할: [41, 84] -> [41] , [84]

 [41]와 [84] 병합 -> [41, 84]

 [50]와 [41, 84] 병합 -> [41, 50, 84]

 [28, 88]와 [41, 50, 84] 병합 -> [28, 41, 50, 84, 88]

 [25, 49, 54, 56, 94]와 [28, 41, 50, 84, 88] 병합 -> [25, 28, 41, 49, 50, 54, 56, 84, 88, 94]

 [10, 24, 38, 51, 62, 71, 76, 81, 85, 91]와 [25, 28, 41, 49, 50, 54, 56, 84, 88, 94] 병합 -> [10, 24, 25, 28, 38, 41, 49, 50, 51, 54, 56, 62, 71, 76, 81, 84, 85, 88, 91, 94]
------------------------------------------------------------------------------------------------------------------------
내림차순 정렬 결과 : [94, 91, 88, 85, 84, 81, 76, 71, 62, 56, 54, 51, 50, 49, 41, 38, 28, 25, 24, 10]
------------------------------------------------------------------------------------------------------------------------
```

### 최댓값 & 최솟값

> **숫자로 이뤄진 리스트에서 최댓값과 최댓값의 개수를 출력하기**
> 
> - **최댓값 알고리즘** : 리스트의 첫번째 값을 기준으로 비교하며 최댓값을 비교하며 정렬하는 알고리즘
> - 리스트 첫번째 원소를 최댓값으로 가정
> - 리스트를 순회하며 각 원소와 현재의 최댓값을 비교
> - 현재 원소가 현재 최댓값보다 크면, 최댓값을 해당 원소로 갱신
> - 리스트 순회가 끝나면 현재의 최댓값이 리스트의 최댓값이 됨
> 
> 최댓값과 최솟값은 동일방식에 로직만 반대형태
> 

```python
import random

def find_max_and_count(nums):
    # 초기 최댓값 설정
    max_val = nums[0]   
    # 최댓값 개수 초기 설정 (처음 최댓값으로 설정된 원소 1개)
    count = 1  

    # 리스트 순회
    for num in nums[1:]:
        # 현재 원소가 최댓값보다 클 경우
        # 현재 원소가 최댓값보다 크다면, 최댓값을 갱신하고 개수를 초기화
        if num > max_val:
            max_val = num  # 최댓값 갱신
            count = 1      # 개수 초기화
        # 현재 원소가 최댓값과 같을 경우
        # 현재 원소와 최댓값이 같다면, 개수를 1 증가
        elif num == max_val:
            count += 1     # 개수 증가

    return max_val, count

def generate_and_analyze():
    # 1~50 사이의 난수 30개 생성
    nums = [random.randint(1, 50) for _ in range(30)]
    print("nums :", nums)

    max_val, count = find_max_and_count(nums)
    print("\n")
    print(f"해당 리스트의 최댓값은 {max_val} 입니다.")
    print("\n")
    print(f"해당 리스트 중 최댓값의 개수는 {count} 개 입니다.")

# 함수 실행
generate_and_analyze()
```

```python
nums : [12, 32, 32, 42, 27, 38, 36, 12, 30, 26, 11, 20, 28, 15, 34, 25, 26, 47, 21, 9, 33, 1, 9, 7, 6, 49, 48, 24, 24, 37]

해당 리스트의 최댓값은 49 입니다.

해당 리스트 중 최댓값의 개수는 1 개 입니다.
```

### 최빈값

> **회차별 로또번호에 대한 빈도수 출력하는 프로그램 만들기**
> 
> - 최빈도 알고리즘 이용해야 함
> - 로또 번호는 1회차당 6개 번호로 1~45사이의 값을 가짐
>     - 로또번호는 난수로 임의 생성해 10회차에 대한 번호를 생성

```python
import random

def generate_lotto_numbers():
    """로또 번호 생성"""
    return sorted(random.sample(range(1, 46), 6))

def count_frequency(total_numbers):
    """번호 빈도수 계산"""
    frequency = [0] * 46
    for numbers in total_numbers:
        for number in numbers:
            frequency[number] += 1
    return frequency

def print_frequency(frequency):
    """빈도수 출력"""
    for i in range(1, 46):
        print(f"번호:\t{i},\t빈도:\t{frequency[i]},\t{'+' * frequency[i]}")

def main_execution():
    total_numbers = [generate_lotto_numbers() for _ in range(10)]
    frequency = count_frequency(total_numbers)
    print_frequency(frequency)

main_execution()
```

```python
번호:	1,	빈도:	3,	+++
번호:	2,	빈도:	1,	+
번호:	3,	빈도:	3,	+++
번호:	4,	빈도:	2,	++
번호:	5,	빈도:	1,	+
번호:	6,	빈도:	0,	
번호:	7,	빈도:	1,	+
번호:	8,	빈도:	2,	++
번호:	9,	빈도:	0,	
번호:	10,	빈도:	0,	
번호:	11,	빈도:	2,	++
번호:	12,	빈도:	5,	+++++
번호:	13,	빈도:	1,	+
번호:	14,	빈도:	1,	+
번호:	15,	빈도:	0,	
번호:	16,	빈도:	0,	
번호:	17,	빈도:	1,	+
번호:	18,	빈도:	2,	++
번호:	19,	빈도:	1,	+
번호:	20,	빈도:	1,	+
번호:	21,	빈도:	1,	+
번호:	22,	빈도:	1,	+
번호:	23,	빈도:	0,	
번호:	24,	빈도:	1,	+
번호:	25,	빈도:	4,	++++
번호:	26,	빈도:	0,	
번호:	27,	빈도:	0,	
번호:	28,	빈도:	0,	
번호:	29,	빈도:	3,	+++
번호:	30,	빈도:	2,	++
번호:	31,	빈도:	3,	+++
번호:	32,	빈도:	0,	
번호:	33,	빈도:	1,	+
번호:	34,	빈도:	3,	+++
번호:	35,	빈도:	1,	+
번호:	36,	빈도:	2,	++
번호:	37,	빈도:	0,	
번호:	38,	빈도:	2,	++
번호:	39,	빈도:	2,	++
번호:	40,	빈도:	3,	+++
번호:	41,	빈도:	1,	+
번호:	42,	빈도:	1,	+
번호:	43,	빈도:	1,	+
번호:	44,	빈도:	0,	
번호:	45,	빈도:	1,	+
```

### 근삿값

> 수심을 입력하면 수온을 출력하기
> - 수심을 입력하면 수온을 출력해야 함
> - 사용자가 입력하는 수심은 표에 없는 값일 수 있음
> - 따라서 근갓값 알고리즘을 이용해 입력된 값의 근갓값에 따라 결과를 도출해야 함

<br>
<br>

---

<수심에 따른 수온 표>

| 수심(m) | 0 | 5 | 10 | 15 | 20 | 25 | 30 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 수온(C) | 24 | 22 | 20 | 16 | 13 | 10 | 6 |



```python
import pandas as pd

# 수심에 따른 수온 표를 딕셔너리로 정의
depth_temperature_dict = {
    0: 24,
    5: 22,
    10: 20,
    15: 16,
    20: 13,
    25: 10,
    30: 6
}

def get_temperature(depth):
    # 입력한 수심이 딕셔너리에 있으면 그 값을 반환
    if depth in depth_temperature_dict:
        return depth_temperature_dict[depth]
    
    # 입력한 수심이 딕셔너리에 없으면, 가장 가까운 두 수심을 찾아 그 사이의 값을 반환
    depths = list(depth_temperature_dict.keys())
    for i in range(len(depths)-1):
        if depths[i] < depth < depths[i+1]:
            return depth_temperature_dict[depths[i]]

def display_table():
    # 수심에 따른 수온 표를 DataFrame으로 생성
    df = pd.DataFrame({
        '수심(m)': list(depth_temperature_dict.keys()),
        '수온(C)': list(depth_temperature_dict.values())
    })
    display(df)

def display_temperature():
    depth = int(input("수심을 입력하세요 : "))
    temperature = get_temperature(depth)
    
    # 수심에 따른 수온 표 출력
    display_table()
    
    print(f"\n깊이 : {depth}m")
    print(f"수온 : {temperature}도")

# 실행
display_temperature()
```

```python
수심을 입력하세요 : 17
깊이 : 17m
수온 : 16도
```

| 수심(m) | 수온 |
| --- | --- |
| 0 | 24 |
| 5 | 22 |
| 10 | 20 |
| 15 | 16 |
| 20 | 13 |
| 25 | 10 |
| 30 | 6 |

### 재귀

> **전월 대비 매출 증감액을 나타내는 프로그램 만들기**
> 
> 
> **<문제풀이 과정>**
> 
> - 매출 정보를 리스트형태로 정의
> - 주어진 매출 리스트에서 현재달과 이전 달의 차이 계산하고 출력
> - 재귀적으로 위 과정을 반복(매 반복시 리스트의 첫번째 원소 제거)
> - 리스트 길이가 1보다 작아지면 재귀 종료

< A상사 2021년 월별 매출 지표>

| 월 | 매출(천원) |
| --- | --- |
| 1월 | 12,000 |
| 2월 | 13,000 |
| 3월 | 12,500 |
| 4월 | 11,000 |
| 5월 | 10,500 |
| 6월 | 98,000 |
| 7월 | 91,000 |
| 8월 | 91,500 |
| 9월 | 10,500 |
| 10월 | 11,500 |
| 11월 | 12,000 |
| 12월 | 12,500 |

```python
# 월별 매출 정보
sales = [12000, 13000, 12500, 11000, 10500, 98000, 91000, 91500, 10500, 11500, 12000, 12500]

def calculate_sales_difference(sales_list):
    # 재귀 종료 조건: 리스트의 길이가 1보다 작으면 함수 종료
    if len(sales_list) < 2:
        return

    # 현재 달과 이전 달의 매출 차이 계산
    difference = sales_list[1] - sales_list[0]
    
    # 계산된 차이 출력
    if difference > 0:
        print(f"sales: {sales_list}\n매출증감액 : +{difference:,}")
    else:
        print(f"sales: {sales_list}\n매출증감액 : {difference:,}")
    
    # 리스트의 첫 번째 원소 제거 후 재귀 호출
    calculate_sales_difference(sales_list[1:])

# 함수 실행
calculate_sales_difference(sales)
```

```python
sales: [12000, 13000, 12500, 11000, 10500, 98000, 91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : +1,000
sales: [13000, 12500, 11000, 10500, 98000, 91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : -500
sales: [12500, 11000, 10500, 98000, 91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : -1,500
sales: [11000, 10500, 98000, 91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : -500
sales: [10500, 98000, 91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : +87,500
sales: [98000, 91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : -7,000
sales: [91000, 91500, 10500, 11500, 12000, 12500]
매출증감액 : +500
sales: [91500, 10500, 11500, 12000, 12500]
매출증감액 : -81,000
sales: [10500, 11500, 12000, 12500]
매출증감액 : +1,000
sales: [11500, 12000, 12500]
매출증감액 : +500
sales: [12000, 12500]
매출증감액 : +500
```

# ✍️ 오늘의 혼잣말

---

- 파이썬을 이용한 알고리즘 학습은 처음에는 어렵게 느껴졌지만, 각 알고리즘을 코드로 구현하면서 이해가 깊어졌다. 특히, 정렬 알고리즘과 검색 알고리즘을 직접 구현해보면서 그 원리와 특징에 대해 명확하게 파악할 수 있었다. 실제 문제 상황에서 어떤 알고리즘을 선택하고 사용할지 판단하는 능력을 키워야겠다고 느꼈다.