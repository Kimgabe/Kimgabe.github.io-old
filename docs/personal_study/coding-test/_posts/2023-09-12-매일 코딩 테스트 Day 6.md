---
layout: single
title:  "[Programmers school] 코딩 기초 트레이닝 Day 6"
categories: coding-test
tag: [마지막 두 원소, 수 조작하기 1, 수 조작하기 2, 수열과 구간 쿼리 3, 수열과 구간 쿼리 2]
toc: true
highlight: false
use_math : true
header:
  teaser: /assets/images/coding-test/luca-bravo-XJXWbfSo2f0-unsplash.jpg
  overlay_image: /assets/images/coding-test/luca-bravo-XJXWbfSo2f0-unsplash.jpg
  overlay_filter: 0.5
  caption: "Photo credit: [**Unsplash**](https://unsplash.com/ko/%EC%82%AC%EC%A7%84/XJXWbfSo2f0)"
---

조건문, 반복문을 응용한 문제들을 풀었습니다.

## 1. 마지막 두 원소

---

<aside>
💡 문제설명

</aside>

- 정수 리스트 `num_list`가 주어질 때, 마지막 원소가 그전 원소보다 크면 마지막 원소에서 그전 원소를 뺀 값을 마지막 원소가 그전 원소보다 크지 않다면 마지막 원소를 두 배한 값을 추가하여 return하도록 solution 함수를 완성해주세요.

<aside>
🔒 제한 사항

</aside>

- 2 ≤ `num_list`의 길이 ≤ 10
- 1 ≤ `num_list`의 원소 ≤ 9

---

<aside>
💡 입출력 예

</aside>

| num_list | result |
| --- | --- |
| [2, 1, 6] | [2, 1, 6, 5] |
| [5, 2, 1, 7, 5] | [5, 2, 1, 7, 5, 10] |




- 입출력 예 #1
    - 마지막 원소인 6이 그전 원소인 1보다 크기 때문에 6 - 1인 5를 추가해 return합니다.
- 입출력 예 #2
    - 마지막 원소인 5가 그전 원소인 7보다 크지 않기 때문에 5의 두 배인 10을 추가해 return합니다.

---

<aside>
🎓 문제풀이 코드(기본 세팅)

</aside>

```python
def solution(num_list):
    answer = []
    return answer
```

---

<aside>
💭 문제 해석

</aside>

- 배열의 각 원소에 접근하는 방법과, 이를 각각 추출해서 연산하는 방법을 이해해야 풀 수 있는 문제
- 배열의 -1번째 원소와 -2번째 원소를 비교해서 조건에 따라 연산해야 함

<aside>
⚙ 문제 풀이 계획

</aside>

- 마지막 원소와 그 직전 원소를 각각 변수로 추출
- 조건문에 따라 두 원소를 비교하여 연산하는 식 작

---

<aside>
✅ 제출한 답

</aside>

```python
def solution(num_list):
    last = num_list[-1]  # 마지막 원소
    second_last = num_list[-2]  # 뒤에서 두 번째 원소
    
    # 마지막 원소가 이전 원소보다 크다면
    if last > second_last:
        num_list.append(last - second_last)
    # 마지막 원소가 이전 원소보다 작거나 같다면
    else:
        num_list.append(last * 2)
    
    return num_list
```

<aside>
➡️ 실행결과

</aside>

```python
테스트 1
입력값 〉	[2, 1, 6]
기댓값 〉	[2, 1, 6, 5]
실행 결과 〉	테스트를 통과하였습니다.
테스트 2
입력값 〉	[5, 2, 1, 7, 5]
기댓값 〉	[5, 2, 1, 7, 5, 10]
실행 결과 〉	테스트를 통과하였습니다.
```

---

<aside>
🤔 피드백

</aside>

- 배열의 길이에 상관없이 인덱싱을 하는 것을 알아야 풀 수 있음
- 처음에는 각 배열에서 원소를 뽑아서 직전 원소와 비교하라는 것으로 잘못이해했었는데 문제를 찬찬히 읽지 않아서 생겼던 문제였음
- 문제 자체에 이미 다 답이 나와 있었던 문제

---

---

## 2. 수 조작하기 1

---

<aside>
💡 문제설명

</aside>

- 정수 `n`과 문자열 `control`이 주어집니다. `control`은 "w", "a", "s", "d"의 4개의 문자로 이루어져 있으며, `control`의 앞에서부터 순서대로 문자에 따라 `n`의 값을 바꿉니다.
    - "w" : `n`이 1 커집니다.
    - "s" : `n`이 1 작아집니다.
    - "d" : `n`이 10 커집니다.
    - "a" : `n`이 10 작아집니다.

위 규칙에 따라 `n`을 바꿨을 때 가장 마지막에 나오는 `n`의 값을 return 하는 solution 함수를 완성해 주세요.

<aside>
🔒 제한 사항

</aside>

- 100,000 ≤ `n` ≤ 100,000
- 1 ≤ `control`의 길이 ≤ 100,000
    - `control`은 알파벳 소문자 "w", "a", "s", "d"로 이루어진 문자열입니다.

---

<aside>
💡 입출력 예

</aside>

| n | control | result |
| --- | --- | --- |
| 0 | "wsdawsdassw" | -1 |

---

- 수 `n`은 `control`에 따라 다음과 같은 순서로 변하게 됩니다.
- 0 → 1 → 0 → 10 → 0 → 1 → 0 → 10 → 0 → -1 → -2 → -1
- 따라서 -1을 return 합니다.

---

<aside>
🎓 문제풀이 코드(기본 세팅)

</aside>

```python
def solution(n, control):
    answer = 0
    return answer
```

---

<aside>
💭 문제 해석

</aside>

- `control` 에 주어진 문자열을 한개씩 체크하면서 정해진 조건에 따라 n의 값이 바뀌어야 함
- 변수내 문자열을 iteration하는 방법과, 조건문, 산술연산을 할줄 알아야 풀 수 있는 문제

<aside>
⚙ 문제 풀이 계획

</aside>

- 입력받은 정수 `n` 을 answer에 할당한 뒤
- control을 순회하며 각 문자열을 하나씩 추출
- 추출된 문자열을 조건에 따라 일치여부를 확인한뒤 해당되는 연산을 하는 `if~elif` 문 작성

---

<aside>
✅ 제출한 답

</aside>

```python
def solution(n, control):
    answer = n
    # 조건에 따른 문자별 연산식
    for char in control:
        if char == "w":
            answer = answer + 1
        elif char == "s":
            answer = answer - 1
        elif char == "d":
            answer = answer + 10
        elif char == "a":
            answer = answer -10
    return answer
```

<aside>
➡️ 실행결과

</aside>

```python
테스트 1
입력값 〉	0, "wsdawsdassw"
기댓값 〉	-1
실행 결과 〉	테스트를 통과하였습니다.
```

---

<aside>
🤔 피드백

</aside>

- iteration하는 것에 대한 개념과 문자열로 된 변수내 문자들을 하나씩 추출해서 활용하는 방법을 알면 쉽게 풀 수 있는 문제

---

---

## 3. 수 조작하기 2

---

<aside>
💡 문제설명

</aside>

- 정수 배열 `numLog`가 주어집니다. 처음에 `numLog[0]`에서 부터 시작해 "w", "a", "s", "d"로 이루어진 문자열을 입력으로 받아 순서대로 다음과 같은 조작을 했다고 합시다.
    - "w" : 수에 1을 더한다.
    - "s" : 수에 1을 뺀다.
    - "d" : 수에 10을 더한다.
    - "a" : 수에 10을 뺀다.
- 그리고 매번 조작을 할 때마다 결괏값을 기록한 정수 배열이 `numLog`입니다. 즉, `numLog[i]`는 `numLog[0]`로부터 총 `i`번의 조작을 가한 결과가 저장되어 있습니다.
- 주어진 정수 배열 `numLog`에 대해 조작을 위해 입력받은 문자열을 return 하는 solution 함수를 완성해 주세요.

<aside>
🔒 제한 사항

</aside>

- 2 ≤ `numLog`의 길이 ≤ 100,000
    - 100,000 ≤ `numLog[0]` ≤ 100,000
    - 1 ≤ `i` ≤ `numLog`의 길이인 모든 `i`에 대해 `|numLog[i] - numLog[i - 1]|`의 값은 1 또는 10입니다.

---

<aside>
💡 입출력 예

</aside>

| numLog | result |
| --- | --- |
| [0, 1, 0, 10, 0, 1, 0, 10, 0, -1, -2, -1] | "wsdawsdassw" |




입출력 예 #1

- result인 "wsdawsdassw"를 따라 `numLog[0]`에서부터 시작해 조작을 하면 `numLog`의 값과 순서대로 일치합니다. 따라서 "wsdawsdassw"를 return 합니다.

<aside>
☝ Hint

</aside>

- "수 조작하기 1" 문제의 `n`값이 `numLog[0]`에 해당하며, 이 문제에서 주어진 `numLog`에 따라 "수 조작하기 1" 문제의 `control`을 구하는 문제라고 이해할 수 있습니다.
- 입출력 예 #1은 "수 조작하기 1" 문제의 입출력 예 #1과 같은 예시이므로 참고하시기 바랍니다.

---

<aside>
🎓 문제풀이 코드(기본 세팅)

</aside>

```python
def solution(numLog):
    answer = ''
    return answer
```

---

<aside>
💭 문제 해석

</aside>

- `numLog`의 배열은 특정 키(w, a, s, d) 를 누를 때마다 변화하는 숫자의 로그값
- 배열의 첫번째 원소는 초기값이고, 그 다음 원소부터는 각 키(w,a,s,d)를 눌렀을때의 결과값을 의미하는 것
- 주어진 `numLog`를 가지고 어떤 키들을 눌러서 그 로그값이 나오는지를 역으로 찾아야 되는 문제

<aside>
⚙ 문제 풀이 계획

</aside>

- answer 에 빈 문자열 생성
- `numLog`의 첫번재 원소부터 (0번째는 제외) 마지막 원소까지 iteration하는 for문 작성
- 현재원소와 이전 원소의 차이(`diff`)를 계산
- 이 `diff`로 어떤 값이 눌렸는지를 찾는 조건문을 작

---

<aside>
✅ 제출한 답

</aside>

```python
def solution(numLog):
    answer = '' # 정답을 담을 변수 생성
    # numLog 내 원소들을 순환 
    for i in range(1, len(numLog)):
        
        # 현재원소와 이전원소간의 차이를 계산
        diff = numLog[i] - numLog[i-1]
        
        # diff에 따라 눌려진 키 값을 추론
        if diff == 1:
            answer += 'w'
        elif diff == -1:
            answer += 's'
        elif diff == 10:
            answer += 'd'
        elif diff == -10:
            answer += 'a'
    return answer
```

<aside>
➡️ 실행결과

</aside>

```python
테스트 1
입력값 〉	[0, 1, 0, 10, 0, 1, 0, 10, 0, -1, -2, -1]
기댓값 〉	"wsdawsdassw"
실행 결과 〉	테스트를 통과하였습니다.
```

---

<aside>
🤔 피드백

</aside>

- 문제를 이해하는거 자체가 좀 어려웠던 것 같다. 입출력 예를 보고 이해가 되기보다 더 헷갈려져서 문제를 문장 별로 쪼개서 보면서 다시 이해했다.
- 0번째 원소인 0을 제외하고 추론을 해야 하는데 이를 생각하지 못해서 애먹음
- numLog는 12개의 원소이고 result는 11개의 문자인점을 빠르게 캐치했다면 더 빨리 문제를 풀 수 있었을텐데 아쉽다. (이런것도 EDA의 중요성의 일종인가 싶기도 하고..)

---

---

## 4. 수열과 구간 쿼리 3

---

<aside>
💡 문제설명

</aside>

- 정수 배열 `arr`와 2차원 정수 배열 `queries`이 주어집니다. `queries`의 원소는 각각 하나의 `query`를 나타내며, `[i, j]` 꼴입니다.
- 각 `query`마다 순서대로 `arr[i]`의 값과 `arr[j]`의 값을 서로 바꿉니다.
- 위 규칙에 따라 `queries`를 처리한 이후의 `arr`를 return 하는 solution 함수를 완성해 주세요.

<aside>
🔒 제한 사항

</aside>

- 1 ≤ `arr`의 길이 ≤ 1,000
    - 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
    - 0 ≤ `i` < `j` < `arr`의 길이

---

<aside>
💡 입출력 예

</aside>

| arr | queries | result |
| --- | --- | --- |
| [0, 1, 2, 3, 4] | [[0, 3],[1, 2],[1, 4]] | [3, 4, 1, 0, 2] |




- 입출력 예 #1
    - 각 쿼리에 따라 `arr`가 다음과 같이 변합니다.
    
    | [0, 1, 2, 3, 4] |
    | --- |
    | [3, 1, 2, 0, 4] |
    | [3, 2, 1, 0, 4] |
    | [3, 4, 1, 0, 2] |
- 따라서 [3, 4, 1, 0, 2]를 return 합니다.

---

<aside>
🎓 문제풀이 코드(기본 세팅)

</aside>

```python
def solution(arr, queries):
    answer = []
    return answer
```

---

<aside>
💭 문제 해석

</aside>

- queries 처럼 2차원 배열에서 각 원소를 어떻게 추출하는지, 정수 배열에서 특정 원소의 값을 어떻게 바꾸는 지 알아야 풀 수 있는 문제

<aside>
⚙ 문제 풀이 계획

</aside>

- queries만큼 iteration하도록 for문을 작성
- arr에서 바꿀 문자들을 queries에서 추출해서 query로 지정
- query의 값들을 arr에서 찾아서 서로 교환하도록 코드 설정

---

<aside>
✅ 제출한 답

</aside>

```python
def solution(arr, queries):
    # queries 만큼 순회
    for query in queries:
        # queries의 query를 추출
        i, j = query
        # arr에서 해당되는 숫자를 교환
        arr[i], arr[j] = arr[j], arr[i]
    return arr
```

<aside>
➡️ 실행결과

</aside>

```python
테스트 1
입력값 〉	[0, 1, 2, 3, 4], [[0, 3], [1, 2], [1, 4]]
기댓값 〉	[3, 4, 1, 0, 2]
실행 결과 〉	테스트를 통과하였습니다.
```

---

<aside>
🤔 피드백

</aside>

- 처음에 원소의 값을 바꾼다는 것을 이해를 잘 못해서 풀이 방법 정하는데 시간이 걸렸던 것 같다.

---

---

## 5. 수열과 구간 쿼리 2

---

<aside>
💡 문제설명

</aside>

- 정수 배열 `arr`와 2차원 정수 배열 `queries`이 주어집니다. `queries`의 원소는 각각 하나의 `query`를 나타내며, `[s, e, k]` 꼴입니다.
- 각 `query`마다 순서대로 `s` ≤ `i` ≤ `e`인 모든 `i`에 대해 `k`보다 크면서 가장 작은 `arr[i]`를 찾습니다.
- 각 쿼리의 순서에 맞게 답을 저장한 배열을 반환하는 solution 함수를 완성해 주세요.
- 단, 특정 쿼리의 답이 존재하지 않으면 -1을 저장합니다.

<aside>
🔒 제한 사항

</aside>

- 1 ≤ `arr`의 길이 ≤ 1,000
    - 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
    - 0 ≤ `s` ≤ `e` < `arr`의 길이
    - 0 ≤ `k` ≤ 1,000,000

---

<aside>
💡 입출력 예

</aside>

| arr | queries | result |
| --- | --- | --- |
| [0, 1, 2, 4, 3] | [[0, 4, 2],[0, 3, 2],[0, 2, 2]] | [3, 4, -1] |




- 입출력 예 #1
    - 첫 번째 쿼리의 범위에는 0, 1, 2, 4, 3이 있으며 이 중 2보다 크면서 가장 작은 값은 3입니다.
    - 두 번째 쿼리의 범위에는 0, 1, 2, 4가 있으며 이 중 2보다 크면서 가장 작은 값은 4입니다.
    - 세 번째 쿼리의 범위에는 0, 1, 2가 있으며 여기에는 2보다 큰 값이 없습니다.
    - 따라서 [3, 4, -1]을 return 합니다.

---

<aside>
🎓 문제풀이 코드(기본 세팅)

</aside>

```python
def solution(arr, queries):
    answer = []
    return answer
```

---

<aside>
💭 문제 해석

</aside>

- `queries` 에 명시된 `query` 들이 통상적으로 `검색조건` 이므로 이들을 `arr` 의 idx로 이해를 하면 문제를 이해할 수 있다.
- 각 `query`마다 순서대로 `s` ≤ `i` ≤ `e`인 모든 `i` 는 arr에서 `arr[s]` 와 `arr[e]` 사이에 있는 원소를 의미한다.
- 이제 `arr` 에서 `query` 로 추출한 조건에 맞는 `i` 중에 정수 `k` 보다 작은 원소값 중 가장 작은 값을 추출하면 되는 것

<aside>
⚙ 문제 풀이 계획

</aside>

- 이전 문제와 마찬가지로 queries를 순회하며 작업
- queries에서 query를 추출해 각각 s, e, k를 추출
- arr에서 s와 e를 활용해 조건을 충족하는 원소들 추출
- 추출된 원소들중 k 보다 큰 원소만 추출
- 추출된 값이 없으면 -1 을 answer 에 입력하고, 그렇지 않으면 min값을 answer에 입

---

<aside>
✅ 제출한 답

</aside>

```python
def solution(arr, queries):
    answer = []
    for query in queries:
        s, e, k = query
        # s와 e 인덱스에 해당하는 배열의 부분을 추출
        sub_arr = arr[s:e+1]
        
        # k보다 큰 값만 추출
        i_list = [i for i in sub_arr if i > k]
        
        # i_list가 비어있지 않으면 최소값을, 비어있으면 -1을 결과에 추가
        if i_list:
            answer.append(min(i_list))
        else:
            answer.append(-1)
            
    return answer
```

<aside>
➡️ 실행결과

</aside>

```python
테스트 1
입력값 〉	[0, 1, 2, 4, 3], [[0, 4, 2], [0, 3, 2], [0, 2, 2]]
기댓값 〉	[3, 4, -1]
실행 결과 〉	테스트를 통과하였습니다.
```

---

<aside>
🤔 피드백

</aside>

- 문제를 이해하는거 자체가 좀 어려웠던 문제
- i를 어디서 찾는건지 잘 파악을 못해서 문제를 몇번씩 읽은것 같다.
- 특히 `s` ≤ `i` ≤ `e`인 모든 `i` 이 부분이 이해가 안되서 계속 읽었는데 arr의 indxing을 하는 거란걸 좀 더 일찍 인지했으면 쉽게 풀지 않았을까 싶다.

---
![](/assets/images/coding-test/프로그래머스-공지용.gif)

---


