---
layout: single
title: '"[SQLD] 3일차 : 본질 식별자 vs 인조식별자"'
categories:
  - sql
tags:
  - sql
  - SQLD
  - 노트정리
  - 데이터모델과SQL
  - 식별자
  - Identifier
  - 본질식별자
  - essential_identifier
  - 인조식별자
  - artificial_identifier
toc: true
highlight: false
use_math: true
header:
  teaser: /assets/images/SQL/sql_teaser.png
  overlay_image: /assets/images/SQL/sql_teaser.png
  overlay_filter: 0.5
  caption: "Photo credit: [**Unsplash**](https://unsplash.com/ko/%EC%82%AC%EC%A7%84/XJXWbfSo2f0)"
---

## 🚦 Summary 
- 데이터 모델에서 본질 식별자와 인조 식별자의 개념과 차이점을 설명
- 중복 데이터 처리 시 본질 식별자와 인조 식별자의 활용 방법 비교
- 동일 상품 중복 주문 사례를 통해 인조 식별자 사용의 장점 강조

---

## 📌 Intro.
- 이번 포스팅에서는 데이터 모델에서 본질 식별자와 인조 식별자의 개념과 차이점에 대해 알아보겠습니다.
- 중복 데이터 처리 시 본질 식별자와 인조 식별자의 활용 방법을 비교해볼 수 있습니다.
- 또한, 동일 상품 중복 주문 사례를 통해 인조 식별자 사용의 장점을 확인해보겠습니다.

---
## 과목범위
![](https://i.imgur.com/kAVtA3r.png)


<br>


# 본질 식별자와 인조 식별자란?

> **본질식별자(Essential Identifier)**: 

- 업무 프로세스에서 자연스럽게 생성되고 업무상 의미를 가지는 식별자입니다. 
	- 예를 들어, 사람의 주민등록번호나 제품의 일련번호가 이에 해당합니다.




> **인조식별자(Artificial Identifier)**: 

- 본질식별자를 대체하기 위해 인위적으로 생성된 식별자로, 보통 일련번호나 시퀀스로 생성됩니다.





- 아래 이미지는 두 식별자를 두 가지 데이터 모델 표기법에 따라 표현한 것 입니다. 

![](https://i.imgur.com/oKWPd82.png)


1. **본질식별자(Natural Identifier) vs 인조식별자(Artificial Identifier)**:
    - IE 표기법은 본질식별자를 사용하여 '주문' 테이블의 주문번호를 나타냅니다.
    - Barker 표기법은 인조식별자를 사용하여 '주문상세' 테이블의 주문번호를 표시하며, 여기서 인조식별자는 시퀀스(SEQUENCE)를 통해 생성됩니다.
      
2. **표기법의 차이점**:
    - IE 표기법에서는 주문 테이블과 주문상세 테이블이 직선으로 연결되어 있고, 주문상세 테이블에는 외래키로 주문번호가 표시됩니다.
    - Barker 표기법에서는 주문번호 옆에 '#'가 본질식별자임을, '*'가 인조식별자임을 나타내며, 주문상세 테이블에도 동일하게 표기됩니다.
      
3. **SQL 쿼리 예제**:
    - IE 방법론에서는 주문번호를 직접 입력하여 '주문상세' 테이블에 데이터를 삽입합니다.
    - Barker 방법론에서는 시퀀스를 사용하여 '주문상세' 테이블의 주문번호를 생성하여 삽입합니다.


<br>

# 인조식별자를 사용하는 이유

## Case : 하나의 주문에 동일상품을 중복으로 주문하고 싶은 경우
![](https://i.imgur.com/uCcZZ3b.png)

- 위 이미지는 동일한 상품을 여러 개 주문하는 경우에 대한 두 가지 데이터 모델링 방식을 보여주고 있습니다.
- 왼쪽은 **본질식별자(Natural Key)를 사용하는 방식**으로, 주문상세(OrderDetail) 테이블에 상품번호(PK), 주문번호(FK), 수량을 저장하고, <font color="#4f81bd">SQL INSERT 문을 통해 동일한 상품을 여러 번 입력</font>하는 방식입니다.
- 오른쪽은 **인조식별자(Surrogate Key)를 사용하는 방식**으로, 주문상세에 인조식별자인 주문상세번호(PK)를 사용하고, 상품번호(FK)와 수량을 저장합니다. <font color="#4f81bd">SQL INSERT 문에서는 동일한 상품이라도 주문상세번호를 다르게 하여 여러 번 입력</font>합니다.

- 즉, 이 이미지는 동일 상품의 중복 주문을 처리하는 두 가지 데이터 모델링 방식의 차이를 보여주는 이미지 입니다.
- 또한, 이를 통해 <font color="#4f81bd">본질식별자 방식보다는 인조식별자를 활용하는 것이 데이터 무결성 측면에서 더 나은 설계</font>임을 알 수 있습니다.
- IE 표기법을 기준으로 왜 인조식별자를 활용하는것이 데이터 무결성 측면에서 더 나은 설계인지 확인해 보겠습니다.

<br>


### 본질 식별자를 사한 중복 데이터 처리의 문제점

![](https://i.imgur.com/oPrb1ba.png)

- 위 이미지는 본질식별자를 사용하여 동일한 상품을 여러 번 주문하는 경우의 데이터 모델과 SQL 쿼리를 보여줍니다.
- 데이터 모델을 보면, '주문' 테이블은 '주문번호'를 기본키로 가지고 있고, '주문상세' 테이블은 '주문번호'와 '제품번호'를 기본키로 사용하고 있습니다. 이는 본질식별자를 사용한 예시입니다.
- <font color="#4f81bd">문제는 동일한 상품을 여러 번 주문할 때 발생</font>합니다. 
- SQL INSERT 문을 보면, <font color="#4f81bd">동일한 주문번호(110001)와 제품번호(1234)가 반복해서 입력</font>되는 것을 볼 수 있습니다. 이는 <font color="#4f81bd">데이터의 중복을 야기하고, 데이터 무결성을 해칠 수 있는 위험</font>이 있습니다.

> 따라서, 본질식별자를 사용하여 중복 데이터를 처리하는 것은 바람직하지 않으며, 대안이 필요합니다.

<br>

### 인조식별자를 활용한 중복 데이터 처리의 개선

![](https://i.imgur.com/u1nawl5.png)

- 위 이미지는 인조식별자를 도입하여 동일한 상품을 여러 번 주문하는 경우의 데이터 모델과 SQL 쿼리를 보여줍니다.
- 데이터 모델에서는 '주문상세' 테이블에 '주문상세번호'라는 인조식별자를 기본키로 추가했습니다. 이는 주문번호와 제품번호의 조합과 관계없이 고유한 값을 가집니다.
- SQL INSERT 문을 보면, 동일한 주문번호(110001)와 제품번호(1234)를 가진 주문이 여러 번 입력되지만, 각각의 주문은 고유한 주문상세번호(1, 2, 3)를 받습니다. 
- 이렇게 함으로써 데이터의 중복을 피할 수 있고, 주문 정보를 보다 효과적으로 관리할 수 있습니다.
- 또한, 주문상세번호를 통해 주문과 제품 간의 관계를 명확하게 정의할 수 있어, 데이터 무결성을 유지하는 데에도 도움이 됩니다.

> 결론적으로, 인조식별자를 활용하면 중복 데이터를 효과적으로 처리할 수 있으며, 데이터의 품질과 관리 효율성을 높일 수 있습니다.





---

## 🎈 Outro.
- 본질 식별자는 업무 프로세스에서 자연스럽게 생성되는 식별자인 반면, 인조 식별자는 본질 식별자를 대체하기 위해 인위적으로 생성된 식별자입니다.
- 중복 데이터 처리 시 본질 식별자를 사용하면 데이터 무결성 문제가 발생할 수 있으므로, 인조 식별자를 활용하는 것이 더 나은 설계 방법입니다.
- 동일 상품 중복 주문 사례에서 인조 식별자를 사용함으로써 데이터 무결성을 유지하고 효과적으로 중복 데이터를 관리할 수 있습니다.
- 데이터 모델링 시 본질 식별자와 인조 식별자의 특성을 이해하고, 상황에 맞게 적절한 식별자를 선택하는 것이 중요합니다.

