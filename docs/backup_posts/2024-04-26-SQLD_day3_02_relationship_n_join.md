---
layout: single
title: '"[SQLD] 3일차 : 관계와 조인의 이해"'
categories:
  - sql
tags:
  - sql
  - SQLD
  - 노트정리
  - 데이터모델과SQL
  - 관계와조인
  - 관계
  - Relationship
  - 조인
  - Join
toc: true
highlight: false
use_math: true
header:
  teaser: /assets/images/SQL/sql_teaser.png
  overlay_image: /assets/images/SQL/sql_teaser.png
  overlay_filter: 0.5
  caption: "Photo credit: [**Unsplash**](https://unsplash.com/ko/%EC%82%AC%EC%A7%84/XJXWbfSo2f0)"
---

## 🚦 Summary
- 데이터베이스에서 조인의 개념과 활용 방법을 설명
- 계층형 데이터 모델과 자기 참조 관계, 그리고 이를 처리하는 Self Join에 대해 소개
- 상호배타적 관계의 개념과 SQL에서의 처리 방법을 UNION ALL과 LEFT OUTER JOIN을 통해 설명

---

## 📌 Intro.
- 이번 포스팅에서는 데이터베이스에서 중요한 개념인 조인에 대해 알아보겠습니다.
- 조인의 기본 개념과 활용 방법, 그리고 계층형 데이터 모델과 자기 참조 관계에 대해 배울 수 있습니다.
- 또한, 상호배타적 관계의 개념과 SQL에서의 처리 방법인 UNION ALL과 LEFT OUTER JOIN에 대해 살펴보겠습니다.

---
## 과목범위
![](https://i.imgur.com/8jbuWwv.png)

<br>


# 조인 (Join)
- Relationship(관계) 는 매핑 키로 데이터 결합이 가능합니다. 이를 SQL에서는 Join이라 합니다.

> 매핑 키 : 한 테이블의 특정 컬럼값을 다른 테이블의 컬럼 값과 합치려고 할때 기준이 되는 키 

![](https://i.imgur.com/ZBpC59O.png)

- 위 데이터 모델을보면 각각의 테이블은 Entity를 의미하며, Entity간 관계를 표현하기 위해 매핑 키를 활용합니다.
- 매핑 키는 <font color="#4f81bd">한 테이블의 특정 컬럼 값이 다른 테이블의 컬럼 값과 일치할 때 두 테이블을 연결(매핑)하는 역할</font>을 합니다.
- 위 데이터 모델을 예시로 보자면, <font color="#4f81bd">'주문' 테이블의 '고객번호' 컬럼은 '고객' 테이블의 '고객번호' 컬럼과 매핑</font>되어 두 테이블이 관계를 맺을 수 있습니다.


- 실제로 데이터를 찾는 작업을 한다고 가정하고 조인에 대해 더 알아 보겠습니다.

> 위 데이터 모델에서 "주문번호가 '1100001' 인 주문의 고객명은 누구인가?!" 라는 작업을 수행하기 위 과정과 이를 구현하기 위한 SQL 쿼리는 아래와 같습니다. 

![](https://i.imgur.com/vSele31.png)


- `주문번호가 1100001`인 주문의 고객명을 찾기 위해 '주문' 테이블과 '고객' 테이블을 조인합니다.
- '주문' 테이블의 '고객번호'가 '고객' 테이블의 '고객번호'와 일치하는 고객명을 조회합니다.
- 조인 조건인 `WHERE A.고객번호 = B.고객번호`를 통해 두 테이블 간의 연결을 정의합니다.

---
<br>

# 계층형 데이터 모델과 조인
## 계층형 데이터 모델?!
 >  💡계층형 데이터 모델이란?!

- **계층형 데이터 모델**은 데이터를 트리 구조로 구성하여 각 요소가 하나의 부모 요소와 여러 자식 요소를 가질 수 있는 방식으로 데이터를 조직화합니다.
- 이 모델에서 데이터는 루트 노드로부터 시작하여 여러 가지 브랜치로 나뉘며, 각 노드는 특정 데이터 항목을 나타냅니다.
- SQL 환경에서 계층형 데이터 모델은 주로 부모-자식 관계를 갖는 테이블을 통해 표현되며, 이러한 관계는 외래키(Foreign Key)를 사용하여 연결됩니다.
- 예를 들어, 조직 구조나 카테고리 분류 같은 데이터를 계층적으로 표현할 때 사용됩니다.


![](https://i.imgur.com/aBwFnu9.png)

- 보통 '관계가 형성' 되는 것은 두 Entity간에 발생합니다. 
- 하지만, <font color="#4f81bd">계층형 데이터 모델에서는 하나의 Entity가 자기 자신과 관계를 맺을 수</font>도 있습니다. 
	- 이를 '자기 참조관계' 라고 합니다. 
	- 그리고 <font color="#4f81bd">SQL에서 이런 "자기 참조 관계"를 조회하는 방법을 'Self Join'</font> 이라 합니다.
- 위 이미지는 자기 참조관계의 예시를 보여주는 이미지 입니다.
	- EMP 테이블에는 직원들의 정보가 있고, MGR 컬럼은 각 row에 있는 직원의 관리자(Manager)가 누구인가를 나타내는 컬럼입니다.
	- 이 컬럼은 같은 테이블의 EMPNO(직원번호) 컬럼과 매핑되어 계층적인 관계를 형성 합니다.

<br>


### Self Join 사용 예시
![](https://i.imgur.com/9jiKJev.png)

> SQL로 "SMITH" 의 관리자가 누구인가? 라는 문제를 풀어야 한다면 위 이미지의 과정을 거쳐 확인할 수 있습니다. 

- 직원 SMITH의 관리자를 찾기 위해 EMP테이블을 Self Join합니다.
	- `FROM EMP A, EMP B` 로 동일한 테이블을 서로 다른 Alies 를 부여해 불러왔습니다.
	- 그리고 `WHERE A.MGR = B.EMPNO` 조건으로 Self Join을 하여 검색을 합니다.
- SMITH의 MGR 컬럼값과 다른 행의 EMPNO 값을 비교해 SMITH의 관리자 이름을 조회합니다.
- 결과적으로 FORD라는 이름이 SMITH의 MGR이란 것을 확인할 수 있습니다.

- 실제 데이터의 구조를 도식화 해보면 아래와 같습니다.

![](https://i.imgur.com/HyinveD.png)


---

<br>

# 상호배타적 관계
## 상호배타적 관계?!
>   상호배타적 관계란 "두 관계 중 하나만 선택될 수 있는 경우" 를 의미합니다.

- 아래 이미지를 예시로 부연설명을 해보겠습니다.

![](https://i.imgur.com/ITrVxAG.png)

- 위 데이터 모델을 기준으로 주문 Entity에는 개인고객과 법인고객중 하나만 관계를 맺을 수 있습니다.
- 즉, 1명의 고객이 개인고객이면서 법인고객이 될 수는 없습니다. (동시에 두 관계를 가질 수 없음)
- 그래서 이를 구분하기 위해 '고객구분코드' 를 사용합니다. 

<br>


## 상호배타적 관계의 SQL 쿼리 예시
![](https://i.imgur.com/WCk7nxb.png)

> **UNION ALL** 
- `UNION ALL`은 두 개 이상의 SELECT 문의 결과를 하나의 결과 집합으로 결합할 때 사용합니다.
- 각 SELECT 문은 동일한 수의 열을 가져야 하며, 해당 열의 데이터 유형도 일치해야 합니다.
- `UNION ALL`은 각 쿼리에서 얻은 모든 결과를 포함합니다. 즉, 중복된 결과도 모두 포함되어 출력됩니다. 이는 여러 테이블 또는 같은 테이블의 서로 다른 정보를 조합할 때 유용합니다.


> **LEFT OUTER JOIN**
- `LEFT OUTER JOIN`은 주로 두 테이블 간의 관계를 기반으로 데이터를 결합할 때 사용되며, 기본 테이블의 모든 레코드와 조인된 테이블에서 일치하는 레코드를 포함합니다.
- 일치하는 레코드가 없는 경우, 조인된 테이블의 열은 NULL 값을 가지게 됩니다. 이를 통해 데이터의 누락 없이 광범위한 데이터 분석이 가능해집니다.
- `LEFT OUTER JOIN`은 주로 데이터 누락을 방지하고, 어떤 데이터가 조건을 충족하지 않는지 파악할 때 사용됩니다.

<br>


> CASE 1: UNION ALL 활용한 상호배타적 관계 조회

```sql
SELECT  B.개인고객명
	FROM 주문 A, 개인고객 B
WHERE A.주문번호 = 1100001
	AND A.고객구분코드 = ’01’
	AND A.개인/법인번호 = B.개인번호 
UNION ALL
SELECT  B.법인명
	FROM 주문 A, 법인고객 B
WHERE A.주문번호 = 1100001
	AND A.고객구분코드 = ’02’
	AND A.개인/법인번호 = B.법인번호
```
- 위 쿼리는 `SELECT B.개인고객명 ~ B.개인번호` 의 조회 결과(A)와 `SELECT B.법인명 ~ = B.법인번호` 의 조회결과(B) 를 UNION ALL 을 통해 합친 결과를 조회 하는 SQL 쿼리문입니다.
- 데이터와 함께 설명하자면, UNION ALL을 사용하여 '주문' 테이블에서 주문번호가 '1100001'인 주문에 대해 '고객 구분 코드'가 '01'일 때는 '개인고객' 테이블을, '02'일 때는 '법인고객' 테이블을 참조하여 해당 고객의 이름이나 법인명을 조회하라는 쿼리문 입니다.
- 이는 두 개의 서로 다른 쿼리 결과를 하나의 결과로 합쳐서 보여주는 방법입니다.
- 다만, 조건에 맞는 레코드가 없을 경우, 즉 조인되는 결과가 없다면 쿼리는 공집합(No Rows)을 출력합니다.
- 이는 주문번호가 1100001인 주문 중에서 지정된 고객구분코드와 개인/법인번호가 해당 고객 테이블에 존재하지 않는 경우에 발생합니다.

<br>



> CASE 2 : LEFT OUTER JOIN 을 활용한 상호배타적 관계 조회

```sql
SELECT  COALESCE(B.개인고객명, C.법인명) 고객명 
	FROM 주문 A
		LEFT OUTER JOIN 개인고객 B
			ON A.개인/법인번호 = B.개인번호
		LEFT OUTER JOIN 법인고객 C
			ON A.개인/법인번호 = C.법인번호
WHERE A.주문번호 = 1100001
```

- 이 SQL 쿼리는 `주문` 테이블에서 주문번호 '1100001'인 주문에 대해 관련된 개인고객명 혹은 법인명을 조회하는 쿼리 이빈다.
- `LEFT OUTER JOIN`을 사용하여 `개인고객` 테이블(`B`)과 `법인고객` 테이블(`C`)을 `주문` 테이블(`A`)에 조인합니다. 이 때 `개인/법인번호`를 기준으로 조인을 수행합니다.
- `COALESCE` 함수는 `개인고객명`과 `법인명` 중 하나라도 존재하는 값을 반환하여 '고객명'이라는 하나의 결과 열에 출력합니다. 만약 두 값 모두 존재하지 않는 경우 NULL을 출력합니다.
- 개인번호와 법인번호가 중복되지 않는다는 전제 하에, 쿼리는 개인번호 또는 법인번호 중 하나와 일치하는 테이블의 데이터를 성공적으로 조인합니다.
- 만약 조인에 성공한 결과가 없다면, 즉 해당 주문번호에 해당하는 개인고객 또는 법인고객 정보가 없을 경우, 결과로 NULL 값을 포함한 한 건의 ROW가 출력됩니다. 이는 `LEFT OUTER JOIN`의 특성으로, 조인된 테이블의 해당 필드에 데이터가 없을 경우 NULL을 반환하기 때문입니다.

- ---

<br>

## 상호배타적 관계의 중요성
- 상호배타적 관계는 관계와 조인 파트에서 중요한 의미를 지닙니다. 
- SQL을 사용하여 데이터베이스 내의 <font color="#4f81bd">복잡한 데이터 구조와 관계를 효과적으로 표현하고, 상황에 맞는 데이터를 정확하게 추출하는 능력</font>을 의미합니다. 
- 여기서 <font color="#4f81bd">상호배타적 관계 구현은 두 관계 중 하나만 선택되어야 할 때, SQL 쿼리를 통해 어떻게 이를 처리하는지를 배우는 것</font>입니다.

<br>

---

## 🎈 Outro.
- 조인은 데이터베이스에서 여러 테이블의 데이터를 연결하여 의미 있는 정보를 추출하는 데 사용되는 중요한 기술입니다.
- 계층형 데이터 모델과 자기 참조 관계를 이해하고, Self Join을 활용하여 이를 처리하는 방법을 배웠습니다.
- 상호배타적 관계는 두 개의 관계 중 하나만 선택되어야 하는 상황을 나타내며, UNION ALL과 LEFT OUTER JOIN을 사용하여 SQL에서 이를 처리할 수 있습니다.
- 조인과 관련된 다양한 개념과 기술을 익히는 것은 효과적인 데이터베이스 활용을 위해 필수적입니다.

